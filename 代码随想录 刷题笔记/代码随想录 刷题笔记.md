# 数组

## [704. 二分查找](https://leetcode.cn/problems/binary-search/)

### 解法1：二分查找（左闭右闭）

$$
O(\log n)+O(1)
$$

```C++
class Solution {
public:
    int search(vector<int>& nums, int target) {
        int left = 0, right = nums.size() - 1;
        while (left < right) {
            int mid = left + right >> 1;
            if (nums[mid] >= target) {
                right = mid;
            }
            else {
                left = mid + 1;
            }
        }
        if (nums[left] == target) {
            return left;
        }
        else {
            return -1;
        }
    }
};
```

## ==[35. 搜索插入位置](https://leetcode.cn/problems/search-insert-position/)==

### 解法1：二分查找（左闭右开）

$$
O(\log n)+O(1)
$$

```C++
class Solution {
public:
    int searchInsert(vector<int>& nums, int target) {
        int left = 0, right = nums.size(); // 注意这里right的取值，本题按照结果，返回值可能为nums.size()
        while (left < right) {
            int mid = left + right >> 1;
            if (nums[mid] >= target) { //划分成[left, mid) 和 [mid, right)
                right = mid;
            }
            else {
                left = mid + 1;
            }
        }
        return left;
    }
};
```

## ==[34. 在排序数组中查找元素的第一个和最后一个位置](https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/)==

### 解法1：二分查找（左闭右闭）

```C++
class Solution {
public:
    vector<int> searchRange(vector<int>& nums, int target) {
        if (nums.size() == 0) {
            return vector<int>{-1, -1};
        }
        vector<int> res(2);
        int left = 0, right = nums.size() - 1; // 注意这里right的取值，和上一题不同，本题按照结果，返回值不可能为nums.size()，即具体的right应该按照题目确定，即到底是用左闭右闭，还是左闭右开
        while (left < right) {
            int mid = left + right >> 1;
            if (nums[mid] >= target) { //划分成[left, mid] 和 [mid + 1, right]
                right = mid;
            }
            else {
                left = mid + 1;
            }
        }
        if (nums[left] == target) {
            res[0] = left;
        }
        else {
            res[0] = -1;
            res[1] = -1;
            return res;
        }

        left = 0, right = nums.size() - 1;
        while (left < right) {
            int mid = left + right + 1 >> 1;
            if (nums[mid] <= target) {
                left = mid;
            }
            else {
                right = mid - 1;
            }
        }
        res[1] = left;
        
        return res;
    }
};
```

## [69. x 的平方根](https://leetcode.cn/problems/sqrtx/)

### 解法1：顺序遍历

$$
O(\sqrt n)+O(1)
$$

```C++
class Solution {
public:
    int mySqrt(int x) {
        int num;
        for (num = 1; num <= x / num; num++);
        return num - 1;
    }
};
```

### 解法2：二分查找（左闭右闭）

$$
O(\log n)+O(1)
$$

```C++
class Solution {
public:
    int mySqrt(int x) {
        int left = 0, right = 46340;
        while (left < right) {
            int mid = left + right + 1 >> 1;
            if (mid * mid <= x) {
                left = mid;
            }
            else {
                right = mid - 1;
            }
        }
        return left;
    }
};
```

## [367. 有效的完全平方数](https://leetcode.cn/problems/valid-perfect-square/)

### 解法1：顺序遍历

$$
O(\sqrt n)+O(1)
$$

```C++
class Solution {
public:
    bool isPerfectSquare(int num) {
        int i;
        for (i = 1; i <= num / i; i++);
        i--;
        if (i * i == num) {
            return true;
        }
        else {
            return false;
        }
    }
};
```

### 解法2：二分查找（左闭右闭）

$$
O(\log n)+O(1)
$$

```C++
class Solution {
public:
    bool isPerfectSquare(int num) {
        int left = 0, right = 46340;
        while (left < right) {
            int mid = left + right + 1 >> 1;
            if (mid * mid <= num) {
                left = mid;
            }
            else {
                right = mid - 1;
            }
        }
        if (left * left == num) {
            return true;
        }
        else {
            return false;
        }
    }
};
```

## [27. 移除元素](https://leetcode.cn/problems/remove-element/)

### 解法1：双指针

$$
O(n)+O(1)
$$

```C++
class Solution {
public:
    int removeElement(vector<int>& nums, int val) {
        int i, j;
        for (i = 0, j = 0; i < nums.size(); i++) {
            if (nums[i] != val) {
                nums[j++] = nums[i];
            }
        }
        return j;
    }
};
```

## [26. 删除有序数组中的重复项](https://leetcode.cn/problems/remove-duplicates-from-sorted-array/)

### 解法1：双指针

$$
O(n)+O(1)
$$

```C++
class Solution {
public:
    int removeDuplicates(vector<int>& nums) {
        int i, j;
        for (i = 0, j = 0; i < nums.size(); i++) {
            if (i == 0 || nums[i] != nums[i - 1]) {
                nums[j++] = nums[i];
            }
        }

        return j;
    }
};
```

## [283. 移动零](https://leetcode.cn/problems/move-zeroes/)

### 解法1：双指针

$$
O(n)+O(1)
$$

```C++
class Solution {
public:
    void moveZeroes(vector<int>& nums) {
        int i, j;
        for (i = 0, j = 0; i < nums.size(); i++) {
            if (nums[i] != 0) {
                nums[j++] = nums[i];
            }
        }
        for (; j < nums.size(); j++) {
            nums[j] = 0;
        }
    }
};
```

## [844. 比较含退格的字符串](https://leetcode.cn/problems/backspace-string-compare/)

### 解法1：双指针

$$
O(n)+O(1)
$$

```C++
class Solution {
public:
    bool backspaceCompare(string s, string t) {
        int i1, j1;
        for (i1 = 0, j1 = 0; i1 < s.length(); i1++) {
            if (s[i1] == '#') {
                if (j1 > 0) {
                    j1--;
                }
            }
            else {
                s[j1++] = s[i1];
            }
        }

        int i2, j2;
        for (i2 = 0, j2 = 0; i2 < t.length(); i2++) {
            if (t[i2] == '#') {
                if (j2 > 0) {
                    j2--;
                }
            }
            else {
                t[j2++] = t[i2];
            }
        }

        if (j1 != j2) {
            return false;
        }
        else {
            for (int i = 0; i < j1; i++) {
                if (s[i] != t[i]) {
                    return false;
                }
            }
            return true;
        }
    }
};
```

## [977. 有序数组的平方](https://leetcode.cn/problems/squares-of-a-sorted-array/)

### 解法1：二分查找（左闭右开）+双指针

$$
O(n)+O(1)
$$

```C++
class Solution {
public:
    vector<int> sortedSquares(vector<int>& nums) {
        int left = 0, right = nums.size();
        while (left < right) {
            int mid = left + right >> 1;
            if (nums[mid] >= 0) {
                right = mid;
            }
            else {
                left = mid + 1;
            }
        }

        int i = left, j = left - 1, k = 0;
        vector<int> res(nums.size());
        while (i < nums.size() && j >= 0) {
            if (nums[i] * nums[i] <= nums[j] * nums[j]) {
                res[k++] = nums[i] * nums[i];
                i++;
            }
            else {
                res[k++] = nums[j] * nums[j];
                j--;
            }
        }
        while (i < nums.size()) {
            res[k++] = nums[i] * nums[i];
            i++;
        }
        while (j >= 0) {
            res[k++] = nums[j] * nums[j];
            j--;
        }
        
        return res;
    }
};
```

## [209. 长度最小的子数组](https://leetcode.cn/problems/minimum-size-subarray-sum/)

### 解法1：双指针

$$
O(n)+O(1)
$$

```C++
class Solution {
public:
    int minSubArrayLen(int target, vector<int>& nums) {
        int i, j, sum = 0, res = INT_MAX;
        for (i = 0, j = 0; i < nums.size(); i++) {
            while (j < nums.size() && sum < target) {
                sum += nums[j++];
            }
            if (sum >= target) {
                res = min(res, j - i);
            }
            sum -= nums[i];
        }
        if (res == INT_MAX) {
            return 0;
        }
        else {
            return res;
        }
    }
};
```

## [904. 水果成篮](https://leetcode.cn/problems/fruit-into-baskets/)

### 解法1：双指针

$$
O(n)+O(1)
$$

```C++
class Solution {
public:
    int totalFruit(vector<int>& fruits) {
        if (fruits.size() < 2) {
            return fruits.size();
        }

        int i, j, res = 0;
        vector<int> type(2, -1);
        vector<int> num(2, 0);
        type[0] = fruits[0];
        num[0] = 1;
        for (i = 0, j = 1; i < fruits.size(); i++) {
            if (j < fruits.size() && type[1] == -1) {
                while (j < fruits.size() && fruits[j] == fruits[j - 1]) {
                    num[0]++;
                    j++;
                }
                if (j < fruits.size()) {
                    type[1] = fruits[j++];
                    num[1] = 1;
                }
            }
            while (j < fruits.size()) {
                if (fruits[j] == type[0]) {
                    num[0]++;
                    j++;
                }
                else if (fruits[j] == type[1]) {
                    num[1]++;
                    j++;
                }
                else {
                    break;
                }
            }
            res = max(res, num[0] + num[1]);
            if (fruits[i] == type[0]) {
                num[0]--;
                if (num[0] == 0) {
                    type[0] = type[1];
                    num[0] = num[1];
                    type[1] = -1;
                    num[1] = 0;
                }
            }
            else {
                num[1]--;
                if (num[1] == 0) {
                    type[1] = -1;
                }
            }
        }

        return res;
    }
};
```

## [76. 最小覆盖子串](https://leetcode.cn/problems/minimum-window-substring/)

### 解法1：滑动窗口

$$
O(n)+O(C)
$$

```C++
class Solution {
public:
    string minWindow(string s, string t) {
        unordered_map<int, int> Count; //记录各个字符在当前访问的s子串和t中出现的次数的差
        unordered_map<int, bool> st; //记录t中出现的字符

        for (int i = 0; i < t.length(); i++) { //记录t中各个字符出现的次数（以负数记录）并标记其出现过
            Count[t[i]]--;
            st[t[i]] = true;
        }
        int differ = 0; //记录子串中仍然缺少的字符数
        for (auto it:Count) {
            if (it.second < 0) { //出现负数，缺少的字符数加一
                differ++;
            }
        }

        int i = 0, j = 0; //双指针，表示当前访问子串
        int minI = s.length(), minJ = -1; //记录最小子串的起始位置和结束为止
        
        while (i < s.length()) {
            Count[s[i]]++; //当前字符出现次数加一
            if (Count[s[i]] == 0 && st[s[i]] == true) { //加一后该字符出现次数的大于等于零且该字符属于t中字符
                differ--;
            }
            if (differ > 0) { //当前子串仍未涵盖t中所有字符，移动i指针后继续下一循环
                i++;
                continue;
            }
            else {
                while (differ == 0) {
                    if (i - j < minI - minJ) {
                        minI = i;
                        minJ = j;
                    }
                    Count[s[j]]--; //j指针右移后，s[j]被移出，字符出现次数减一
                    if (Count[s[j]] == -1 && st[s[j]] == true) { //减一后该字符出现次数的差为-1且该字符属于t中字符
                        differ++;
                        i++;
                    }
                    j++;
                }
            }
        }

        if (minJ != -1) {
            return s.substr(minJ, minI - minJ + 1);
        }
        else {
            return "";
        }
    }
};
```

## [59. 螺旋矩阵 II](https://leetcode.cn/problems/spiral-matrix-ii/)

### 解法1：模拟

$$
O(n^2)+O(1)
$$

```C++
class Solution {
public:
    vector<vector<int>> generateMatrix(int n) {
        vector<vector<int>> res(n, vector<int>(n));
        int t = 0, b = n - 1, l = 0, r = n - 1, k = 1;
        while (k <= n * n) {
            for (int i = l; i <= r; i++, k++) {
                res[t][i] = k;
            }
            t++;
            for (int i = t; i <= b; i++, k++) {
                res[i][r] = k;
            }
            r--;
            for (int i = r; i >= l; i--, k++) {
                res[b][i] = k;
            }
            b--;
            for (int i = b; i >= t; i--, k++) {
                res[i][l] = k;
            }
            l++;
        }

        return res;
    }
};
```

## [54. 螺旋矩阵](https://leetcode.cn/problems/spiral-matrix/)

### 解法1：模拟

$$
O(n^2)+O(1)
$$

```C++
class Solution {
public:
    vector<int> spiralOrder(vector<vector<int>>& matrix) {
        int m = matrix.size(), n = matrix[0].size(); //记录矩阵的行数和列数
        vector<int> v; //结果数组
        int u = 0, d = m - 1, l = 0, r = n - 1; //记录当前要处理的最上行，最下行，最左行，最右行
        while (u <= d && l <= r) { //当最上行和最下行，最左行和最右行未相遇时，继续处理
            for (int i = l; i <= r; i++) { //处理最上行
                v.push_back(matrix[u][i]);
            }
            if (++u > d) { //最上行下移，且当与最下行相遇时，退出循环
                break;
            }
            for (int i = u; i <= d; i++) { //处理最右行
                v.push_back(matrix[i][r]);
            }
            if (--r < l) { //最右行左移，且当与最左行相遇时，退出循环
                break;
            }
            for (int i = r; i >= l; i--) { //处理最下行
                v.push_back(matrix[d][i]);
            }
            if (--d < u) {
                break; //最下行上移，且当与最上行相遇时，退出循环
            }
            for (int i = d; i >= u; i--) { //处理最左行
                v.push_back(matrix[i][l]);
            }
            if (++l > r) {
                break; //最左行右移，且当与最右行相遇时，退出循环
            }
        }

        return v;
    }
};
```

## -------以下为额外题目-------

## [1365. 有多少小于当前数字的数字](https://leetcode.cn/problems/how-many-numbers-are-smaller-than-the-current-number/)

### 解法1：哈希+前缀和

$$
O(n)+O(C)
$$

```C++
class Solution {
public:
    vector<int> smallerNumbersThanCurrent(vector<int>& nums) {
        vector<int> cnt(101, 0);
        for (int i = 0; i < nums.size(); i++) {
            cnt[nums[i]]++;
        }
        for (int i = 1; i < 101; i++) {
            cnt[i] += cnt[i - 1];
        }
        
        vector<int> res(nums.size(), 0);
        for (int i = 0; i < nums.size(); i++) {
            if (nums[i] == 0) {
                continue;
            }
            res[i] = cnt[nums[i] - 1];
        }

        return res;
    }
};
```

## [941. 有效的山脉数组](https://leetcode.cn/problems/valid-mountain-array/)

### 解法1：双指针

$$
O(n)+O(1)
$$

```C++
class Solution {
public:
    bool validMountainArray(vector<int>& arr) {
        int left = 0, right = arr.size() - 1;
        while (left < right && arr[left] < arr[left + 1]) {
            left++;
        }
        while (left < right && arr[right] < arr[right - 1]) {
            right--;
        }
        if (left == arr.size() - 1 || right == 0 || left != right) {
            return false;
        }
        else {
            return true;
        }
    }
};
```

## [1207. 独一无二的出现次数](https://leetcode.cn/problems/unique-number-of-occurrences/)

### 解法1：哈希

$$
O(n)+O(n)
$$

```C++
class Solution {
public:
    bool uniqueOccurrences(vector<int>& arr) {
        unordered_map<int, int> occur;
        for (const auto& x: arr) {
            occur[x]++;
        }
        unordered_set<int> times;
        for (const auto& x: occur) {
            times.insert(x.second);
        }
        return times.size() == occur.size();
    }
};
```

## [189. 轮转数组](https://leetcode.cn/problems/rotate-array/)

### 解法1：三次翻转

$$
O(n)+O(1)
$$

```C++
class Solution {
public:
    void rotate(vector<int>& nums, int k) {
        k = k % nums.size(); //当k大于数组个数时，轮转结果和k取余后是一样的
        for (int i = 0; i < nums.size() / 2; i++) { //对数组整体翻转
            swap(nums[i], nums[nums.size() - 1 - i]);
        }
        for (int i = 0; i < k / 2; i++) { //翻转前k个数
            swap(nums[i], nums[k - 1 - i]);
        }
        for (int i = k; i <(nums.size() + k) / 2; i++) { //对后nums.size()-k个数进行翻转
            swap(nums[i], nums[nums.size() - 1 - (i - k)]);
        }
    }
};
```

## [724. 寻找数组的中心下标](https://leetcode.cn/problems/find-pivot-index/)

### 解法1：前缀和

$$
O(n)+O(1)
$$

```C++
class Solution {
public:
    int pivotIndex(vector<int>& nums) {
        int sum = 0;
        for (int i = 0; i < nums.size(); i++) {
            sum += nums[i];
        }

        int preSum = 0;
        for (int i = 0; i < nums.size(); i++) {
            if (preSum * 2 + nums[i] == sum) {
                return i;
            }
            preSum += nums[i];
        }

        return -1;
    }
};
```

## [922. 按奇偶排序数组 II](https://leetcode.cn/problems/sort-array-by-parity-ii/)

### 解法1：双指针

$$
O(n)+O(1)
$$

```C++
class Solution {
public:
    vector<int> sortArrayByParityII(vector<int>& nums) {
        int i = 0, j = 1;
        while (i < nums.size() && j < nums.size()) {
            while (i < nums.size() && nums[i] % 2 == 0) {
                i = i + 2;
            }
            while (j < nums.size() && nums[j] % 2 == 1) {
                j = j + 2;
            }
            if (i < nums.size() && j < nums.size()) {
                swap(nums[i], nums[j]);
            }
        }
        return nums;
    }
};
```

# 链表

## [203. 移除链表元素](https://leetcode.cn/problems/remove-linked-list-elements/)

### 解法1：遍历

$$
O(n)+O(1)
$$

```C++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* removeElements(ListNode* head, int val) {
        if (head == NULL) {
            return head;
        }
        
        ListNode* dummyHead = new ListNode();
        dummyHead->next = head;
        ListNode* pre = dummyHead, * cur = head;
        while (cur != NULL) {
            if (cur->val == val) {
                pre->next = cur->next;
                cur = cur->next;
            }
            else {
                pre = pre->next;
                cur = cur->next;
            }
        }
        
        return dummyHead->next;
    }
};
```

## [707. 设计链表](https://leetcode.cn/problems/design-linked-list/)

### 解法1：模拟

$$
O(n)+O(1)
$$

```C++
class MyLinkedList {
    struct LinkedNode{
        int val;
        LinkedNode* next;
        LinkedNode(int x): val(x), next(NULL){}
    };

    LinkedNode* dummyHead;
    int Size;

public:
    MyLinkedList() {
        dummyHead = new LinkedNode(0);
        Size = 0;
    }
    
    int get(int index) {
        if (index >= Size || index < 0) {
            return -1;
        }
        LinkedNode* node = dummyHead->next;
        while (index--) {
            node = node->next;
        }
        return node->val;
    }
    
    void addAtHead(int val) {
        LinkedNode* newNode = new LinkedNode(val);
        newNode->next = dummyHead->next;
        dummyHead->next = newNode;
        Size++;
    }
    
    void addAtTail(int val) {
        LinkedNode* newNode = new LinkedNode(val);
        LinkedNode* node = dummyHead;
        while (node->next != NULL) {
            node = node->next;
        }
        node->next = newNode;
        Size++;
    }
    
    void addAtIndex(int index, int val) {
        if (index > Size) {
            return;
        }
        if (index < 0) {
            index = 0;
        }
        LinkedNode* newNode = new LinkedNode(val);
        LinkedNode* pre = dummyHead, * node = dummyHead->next;
        while (index--) {
            pre = pre->next;
            node = node->next;
        }
        newNode->next = node;
        pre->next = newNode;
        Size++;
    }
    
    void deleteAtIndex(int index) {
        if (index < 0 || index >= Size) {
            return;
        }
        LinkedNode* pre = dummyHead, * node = dummyHead->next;
        while (index--) {
            pre = pre->next;
            node = node->next;
        }
        pre->next = node->next;
        Size--;
    }
};

/**
 * Your MyLinkedList object will be instantiated and called as such:
 * MyLinkedList* obj = new MyLinkedList();
 * int param_1 = obj->get(index);
 * obj->addAtHead(val);
 * obj->addAtTail(val);
 * obj->addAtIndex(index,val);
 * obj->deleteAtIndex(index);
 */
```

## [206. 反转链表](https://leetcode.cn/problems/reverse-linked-list/)

### 解法1：头插法

$$
O(n)+O(1)
$$

```C++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        ListNode* dummyHead = new ListNode();
        ListNode* node = head, * temp = NULL;
        while (node != NULL) {
            temp = node;
            node = node->next;
            temp->next = dummyHead->next;
            dummyHead->next = temp;
        }

        return dummyHead->next;
    }
};
```

## [24. 两两交换链表中的节点](https://leetcode.cn/problems/swap-nodes-in-pairs/)

### 解法1：尾插法

$$
O(n)+O(1)
$$

```C++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* swapPairs(ListNode* head) {
        if (head == NULL || head->next == NULL) { //少于两个节点，不需要交换，直接返回head
            return head;
        }
        ListNode * dummyHead = new ListNode(0); //增加虚拟头节点统一操作
        dummyHead->next = head;
        ListNode * pre = dummyHead, * p1 = pre->next, * p2 = p1->next;
        while (p1 && p2) {
            p1->next = p2->next; //交换
            pre->next = p2;
            p2->next = p1;
            pre = pre->next->next; //移动pre，p1和p2
            p1 = pre->next;
            if (p1) {
                p2 = p1->next;
            }
        }
        return dummyHead->next;
    }
};
```

## [19. 删除链表的倒数第 N 个结点](https://leetcode.cn/problems/remove-nth-node-from-end-of-list/)

### 解法1：双指针

$$
O(n)+O(1)
$$

```C++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* removeNthFromEnd(ListNode* head, int n) {
        ListNode * dummyHead = new ListNode(0), * pre = dummyHead; //增加虚拟头节点统一操作
        dummyHead->next = head;
        ListNode * low = head, * fast = head; //双指针，一个走快点
        while (n--) { //快指针先走n步
            fast = fast ->next;
        }
        while (fast) { //快指针走到底时，慢指针走到倒数第n个节点
            pre = pre->next;
            low = low->next;
            fast = fast->next;
        }
        pre->next = low->next; //删除倒数第n个节点
        low->next = NULL;
        return dummyHead->next;
    }
};
```

## [面试题 02.07. 链表相交](https://leetcode.cn/problems/intersection-of-two-linked-lists-lcci/)

### 解法1：双指针

$$
O(n)+O(1)
$$

```C++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
        ListNode *p = headA, *q = headB; //用于遍历两个单链表
        int m = 0, n = 0; //记录链表A和链表B的结点个数
        while (p != NULL) { //记录链表A的结点个数
            p = p->next;
            m++;
        }
        while (q != NULL) { //记录链表B的结点个数
            q = q->next;
            n++;
        }
        int k; //记录两个链表的结点个数之差
        if (m >= n) { //p重置为个数多的那个链表的头结点，q重置为个数少的那个链表的头结点
            p = headA;
            q = headB;
            k = m - n;
        }
        else {
            p = headB;
            q = headA;
            k = n - m;
        }
        for (int i = 0; i < k; i++) { //p往后移动k个结点，控制p和q离相交节点的结点个数相同
            p = p->next;
        }
        while (p != q) { //向后同步移动p和q，直到二者相遇或同时为NULL
            p = p->next;
            q = q->next;
        }
        return p;
    }
};
```

## ==[142. 环形链表 II](https://leetcode.cn/problems/linked-list-cycle-ii/)==

### 解法1：快慢指针

$$
O(n)+O(1)
$$

```C++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode *detectCycle(ListNode *head) {
        ListNode* dummyHead = new ListNode(0);
        dummyHead->next = head;
        ListNode* slow = dummyHead, * fast = dummyHead;
        while (fast != NULL && fast->next != NULL) { // while里的条件非常常用
            slow = slow->next;
            fast = fast->next->next;
            if (slow == fast) {
                slow = dummyHead;
                while (slow != fast) {
                    slow = slow->next;
                    fast = fast->next;
                }
                return slow;
            }
        }
        return NULL;
    }
};
```

## -------以下为额外题目-------

## ==[234. 回文链表](https://leetcode.cn/problems/palindrome-linked-list/)==

### 解法1：快慢指针

$$
O(n)+O(1)
$$

```C++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    bool isPalindrome(ListNode* head) {
        if (head == NULL || head->next == NULL) { //若节点数少于两个，则必为回文链表
            return true;
        }

        ListNode* dummyHead1 = new ListNode();
        dummyHead1->next = head;
        ListNode* slow = dummyHead1, * fast = dummyHead1; //快慢指针
        while (fast != NULL && fast->next != NULL) { //当fast后继指针不足两个时，退出循环
            slow = slow->next; //慢指针走一步
            fast = fast->next->next; //快指针走两步
        }
        
        //使用头插法将原链表后半段逆置
        ListNode* p = slow->next, * q;
        ListNode* dummyHead2 = new ListNode();
        while (p != NULL) {
            q = p;
            p = p->next;
            q->next = dummyHead2->next;
            dummyHead2->next = q;
        }
        
        //完成逆置后，两个链表除了第一个链表可能多一个节点，其他节点的值必须相同
        p = dummyHead1->next;
        q = dummyHead2->next;
        while (q != NULL) {
            if (p->val != q->val) { //当节点值不相同时，退出循环
                break;
            }
            p = p->next;
            q = q->next;
        }
        

        if (q == NULL) { //第二个链表走到了最后，说明是回文链表
            return true;
        }
        else { //第二个链表没走到最后，说明中途出现了值不同的结点，不是回文链表
            return false;
        }
    }
};
```

### ==笔记==

```c++
ListNode* slow = dummyHead, * fast = dummyHead;
while (fast != NULL && fast->next != NULL) {
    /*...*/
}
```

**二分链表的常用操作**，退出循环后，若节点个数（不算虚拟头节点）为单数，则slow指向中间节点，若为偶数，则slow指向中线左侧节点

## [143. 重排链表](https://leetcode.cn/problems/reorder-list/)

### 解法1：快慢指针

$$
O(n)+O(1)
$$

```C++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    void reorderList(ListNode* head) {
        ListNode* dummyHead1 = new ListNode(), * dummyHead2 = new ListNode();
        dummyHead1->next = head;
        ListNode* slow = dummyHead1, * fast = dummyHead1;
        while (fast != NULL && fast->next != NULL) {
            slow = slow->next;
            fast = fast->next->next;
        }

        ListNode* node = slow->next;
        slow->next = NULL;
        while (node != NULL) {
            ListNode* temp = node;
            node = node->next;
            temp->next = dummyHead2->next;
            dummyHead2->next = temp;
        }

        ListNode* node1 = dummyHead1->next, * node2 = dummyHead2->next;
        while (node1 != NULL && node2 != NULL) {
            ListNode* temp = node2;
            node2 = node2->next;
            temp->next = node1->next;
            node1->next = temp;
            node1 = node1->next->next;
        }

        head = dummyHead1->next;
    }
};
```

## [141. 环形链表](https://leetcode.cn/problems/linked-list-cycle/)

### 解法1：快慢指针

$$
O(n)+O(1)
$$

```C++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    bool hasCycle(ListNode *head) {
        ListNode* dummyHead = new ListNode(0);
        dummyHead->next = head;
        ListNode* slow = dummyHead, * fast = dummyHead;
        while (fast != NULL && fast->next != NULL) {
            slow = slow->next;
            fast = fast->next->next;
            if (slow == fast) {
                return true;
            }
        }
        return false;
    }
};
```

# 哈希表

## [242. 有效的字母异位词](https://leetcode.cn/problems/valid-anagram/)

### 解法1：哈希

$$
O(n)+O(C)
$$

```C++
class Solution {
public:
    bool isAnagram(string s, string t) {
        if (s.length() != t.length()) {
            return false;
        }
        int cnt[26] = {0};
        for (int i = 0; i < s.length(); i++) {
            cnt[s[i] - 'a']++;
            cnt[t[i] - 'a']--;
        }
        for(int i = 0; i < 26; i++) {
            if (cnt[i] != 0) {
                return false;
            }
        }
        return true;
    }
};
```

## [383. 赎金信](https://leetcode.cn/problems/ransom-note/)

### 解法1：哈希

$$
O(n)+O(C)
$$

```C++
class Solution {
public:
    bool canConstruct(string ransomNote, string magazine) {
        int record[26] = {0};
        for (int i = 0; i < ransomNote.length(); i++) {
            record[ransomNote[i] - 'a']++;
        }
        for (int i = 0; i < magazine.length(); i++) {
            record[magazine[i] - 'a']--;
        }
        for (int i = 0; i < 26; i++) {
            if (record[i] > 0) {
                return false;
            }
        }
        return true;
    }
};
```

## ==[49. 字母异位词分组](https://leetcode.cn/problems/group-anagrams/)==

### 解法1：哈希

$$
O(nk\log k)+O(nk)
$$

```C++
class Solution {
public:
    vector<vector<string>> groupAnagrams(vector<string>& strs) {
        unordered_map<string, vector<string>> hash;
        for (int i = 0; i < strs.size(); i++){
            string ans = strs[i];
            sort(ans.begin(), ans.end());
            hash[ans].push_back(strs[i]);
        }
        vector<vector<string>> result;
        for (auto &it:hash) {
            result.push_back(it.second);
        }
        return result;
    }
};
```

## ==[438. 找到字符串中所有字母异位词](https://leetcode.cn/problems/find-all-anagrams-in-a-string/)==

### 解法1：滑动窗口+哈希

$$
O(n+m+C)+O(C)
$$

```C++
class Solution {
public:
    vector<int> findAnagrams(string s, string p) {
        int lenS = s.length(), lenP = p.length(); //记录两个字符串长度
        if (lenS < lenP) { //字符串s长度小于字符串p，则必然没有子串
            return vector<int>();
        }
        int count[26] = {0}; //记录当前子串各字符在s中出现的次数-p中出现的次数（字符差）
        int differ = 0; //记录当前子串和p中有差异的字符的个数

        for (int i = 0; i < lenP; i++) { //从0开始的子串中各字符差
            count[s[i] - 'a']++;
            count[p[i] - 'a']--;
        }

        for (int i = 0; i < 26; i++) { //统计开始子串和p有差异的字符个数
            if (count[i] != 0) {
                differ++;
            }
        }

        vector<int> result; //记录所有p的异位词子串的起始索引

        if (differ == 0) {
            result.push_back(0); //differ为0，说明开始子串就是p的异位词
        }

        for (int i = 0; i < lenS -lenP; i++) { //考察i+1至i+lenP的子串是否为p的异位词
            //上一循环结束的子串为i至i+lenP-1，该子串移出第i位，加入第i+lenP位，为要考察的i+1至i+lenP的子串
            if (count[s[i] - 'a'] == 0) { //第i位字符在i至i+lenP-1的子串中出现次数刚好和p中相同，则移出后differ+1，即有差异的字符个数加一
                differ++;
            }
            else if (count[s[i] - 'a'] == 1) { //第i位字符在i至i+lenP-1的子串中出现次数刚好比p中错一次，则移出后differ-1，即有差异的字符个数减一
                differ--;
            }
            count[s[i] - 'a']--;

            if (count[s[i + lenP] - 'a'] == 0) { //移入第i+lenP位字符，操作原因同上
                differ++;
            }
            else if (count[s[i + lenP] - 'a'] == -1) {
                differ--;
            }
            count[s[i + lenP] - 'a']++;

            if (differ == 0) { //differ为0，说明要考察的i+1至i+lenP的子串就是p的异位词
                result.push_back(i + 1);
            }
        }

        return result;
    }
};
```

## [349. 两个数组的交集](https://leetcode.cn/problems/intersection-of-two-arrays/)

### 解法1：哈希

$$
O(n)+O(C)
$$

```C++
class Solution {
public:
    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {
        int hash[1001] = {0};
        for (int i = 0; i < nums1.size(); i++) {
            hash[nums1[i]] = 1;
        }
        for (int i = 0; i < nums2.size(); i++) {
            if (hash[nums2[i]] == 1) {
                hash[nums2[i]] = 2;
            }
        }

        vector<int> result;
        for (int i = 0; i <= 1000; i++) {
            if (hash[i] == 2) {
                result.push_back(i);
            }
        }

        return result;
    }
};
```

## [350. 两个数组的交集 II](https://leetcode.cn/problems/intersection-of-two-arrays-ii/)

### 解法1：哈希

$$
O(n)+O(C)
$$

```C++
class Solution {
public:
    vector<int> intersect(vector<int>& nums1, vector<int>& nums2) {
        int cnt[1005]={0};
        for (int i = 0; i < nums1.size(); i++) {
            cnt[nums1[i]]++;
        }
        vector<int> result;
        for (int i = 0; i < nums2.size(); i++) {
            if (cnt[nums2[i]]>0) {
                result.push_back(nums2[i]);
                cnt[nums2[i]]--;
            }
        }
        return result;
    }
};
```

## [202. 快乐数](https://leetcode.cn/problems/happy-number/)

### 解法1：哈希

$$
O(\log n)+O(\log n)
$$

```C++
class Solution {
public:
    bool isHappy(int n) {
        unordered_set<long long> uset;
        long long sum;
        while (true) {
            sum = 0;
            while (n != 0) {
                sum += (long long)(n % 10) * (n % 10);
                n /= 10;
            }
            if (sum == 1) {
                return true;
            }
            if (uset.find(sum) != uset.end()) {
                return false;
            }
            else {
                uset.insert(sum);
                n = sum;
            }
        }
    }
};
```

### 方法2：快慢指针

$$
O(\log n)+O(1)
$$

```C++
class Solution {
public:
    int get_next(int n) {
        int sum = 0;
        while (n != 0) {
            sum += (long long)(n % 10) * (n % 10);
            n /= 10;
        }
        return sum;
    }
    bool isHappy(int n) {
        int slow = n, fast = n;
        while (true) {
            slow = get_next(slow);
            fast = get_next(get_next(fast));
            if (slow == 1 || fast == 1) {
                return true;
            }
            if (slow == fast) {
                return false;
            }
        }
    }
};
```

## [1. 两数之和](https://leetcode.cn/problems/two-sum/)

### 解法1：哈希

$$
O(n)+O(n)
$$

```C++
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        unordered_map<int, int> hash;
        for (int i = 0; i < nums.size(); i ++){
            if (hash.find(target - nums[i]) == hash.end()) {
                hash[nums[i]] = i;
            }
            else {
                return vector<int>{hash[target - nums[i]], i};
            }
        }
        return vector<int>();
    }
};
```

## [454. 四数相加 II](https://leetcode.cn/problems/4sum-ii/)

### 解法1：哈希

$$
O(n^2)+O(n^2)
$$

```C++
class Solution {
public:
    int fourSumCount(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3, vector<int>& nums4) {
        unordered_map<int, int> hash;
        for (int a: nums1) {
            for (int b: nums2) {
                hash[a + b]++;
            }
        }
        int count = 0;
        for (int c: nums3) {
            for (int d: nums4) {
                auto it = hash.find(0 - (c + d));
                if (it != hash.end()) {
                    count += it->second;
                }
            }
        }
        return count;
    }
};
```

## [15. 三数之和](https://leetcode.cn/problems/3sum/)

### 解法1：排序+双指针

$$
O(n^2)+O(\log n)
$$

```C++
class Solution {
public:
    vector<vector<int>> threeSum(vector<int>& nums) {
        sort(nums.begin(), nums.end()); //排序，为后续操作做准备

        vector<vector<int>> result; //记录结果
        for(int i = 0; i < nums.size(); i++) {
            if (nums[i] > 0) { //当前访问的数大于0，说明后续已不会再出现三数之和等于0，可以直接退出
                break;
            }
            if (i > 0 && nums[i] == nums[i - 1]) { //避免重复
                continue;
            }
            int j = i + 1, k = nums.size() - 1; //从i位后面的数中开始找与nums[i]相加,和为0的两个数
            while (j < k) { //当j和k相等时，遍历结束
                if (nums[i] + nums[j] + nums[k] == 0) { //三数之和为0
                    result.push_back(vector<int>{nums[i], nums[j], nums[k]}); //记录到结果中
                    j++, k--; //j后移，k前移
                    while (j < k && nums[j] == nums[j - 1]) { //避免重复
                        j++;
                    }
                    while (j < k && nums[k] == nums[k + 1]) { //避免重复
                        k--;
                    }
                }
                else if (j < k && nums[i] + nums[j] + nums[k] < 0) { //和太小，需要增大，j后移
                    j++;
                }
                else { //和太大，需要减小，k前移
                    k--;
                }
            }
        }

        return result;
    }
};
```

## [18. 四数之和](https://leetcode.cn/problems/4sum/)

### 解法1：排序+双指针

$$
O(n^3)+O(\log n)
$$

```C++
class Solution {
public:
    vector<vector<int>> fourSum(vector<int>& nums, int target) {
        vector<vector<int>> result;
        sort(nums.begin(), nums.end());
        for (int i = 0; i < nums.size(); i++) {
            if (nums[i] > target && nums[i] >= 0) {
                break;
            }
            if (i > 0 && nums[i] == nums[i - 1]) {
                continue;
            }
            for (int j = i + 1; j < nums.size(); j++) {
                if (nums[i] + nums[j] > target && nums[i] + nums[j] >= 0) {
                    break;
                }
                if (j > i + 1 && nums[j] == nums[j - 1]) {
                    continue;
                }
                int left = j + 1, right = nums.size() - 1;
                while (left < right) {
                    if ((long long)nums[i] + nums[j] + nums[left] + nums[right] > target) {
                        right--;
                    }
                    else if ((long long)nums[i] + nums[j] + nums[left] + nums[right] < target) {
                        left++;
                    }
                    else {
                        result.push_back({nums[i], nums[j], nums[left], nums[right]});
                        left++, right--;
                        while (left < right && nums[left] == nums[left - 1]) {
                            left++;
                        }
                        while (left < right && nums[right] == nums[right + 1]) {
                            right--;
                        }
                    }
                }
            }
        }
        return result;
    }
};
```

## -------以下为额外题目-------

## [205. 同构字符串](https://leetcode.cn/problems/isomorphic-strings/)

### 解法1：

$$
O(n)+O(C)
$$

```C++
class Solution {
public:
    bool isIsomorphic(string s, string t) {
        vector<int> s2t(128, -1);
        vector<bool> t2s(128, false);
        for (int i = 0; i < s.length(); i++) {
            if (s2t[s[i]] == t[i]) {
                continue;
            }
            else if (s2t[s[i]] == -1 && t2s[t[i]] == false) {
                s2t[s[i]] = t[i];
                t2s[t[i]] = true;
            }
            else {
                return false;
            }
        }
        return true;
    }
};
```

## [1002. 查找共用字符](https://leetcode.cn/problems/find-common-characters/)

### 解法1：哈希

$$
O(n(m+C))+O(C)
$$

```C++
class Solution {
public:
    vector<string> commonChars(vector<string>& words) {
        string str = "abcdefghijklmnopqrstuvwxyz";
        
        int cnt[26] = {0};
        for (int i = 0; i < words.size(); i++) {
            int temp[26] = {0};
            for (int j = 0; j < words[i].length(); j++) {
                temp[words[i][j] - 'a']++;
            }
            for (int j = 0; j < 26; j++) {
                if (i == 0) {
                    cnt[j] = temp[j];
                }
                else {
                    cnt[j] = min(cnt[j], temp[j]);
                }
            }
        }

        vector<string> result;
        for (int i = 0; i < 26; i++) {
            for (int j = 0; j < cnt[i]; j++) {
                result.push_back(str.substr(i, 1));
            }
        }

        return result;
    }
};
```

# 字符串

## [344. 反转字符串](https://leetcode.cn/problems/reverse-string/)

### 解法1：题意

$$
O(n)+O(1)
$$

```C++
class Solution {
public:
    void reverseString(vector<char>& s) {
        for (int i = 0; i < s.size() / 2; i++) {
            swap(s[i], s[s.size() - 1 - i]);
        }
    }
};
```

## [541. 反转字符串 II](https://leetcode.cn/problems/reverse-string-ii/)

### 解法1：题意

$$
O(n)+O(1)
$$

```C++
class Solution {
public:
    string reverseStr(string s, int k) {
        for (int i = 0; i < s.length(); i += 2 * k) {
            if (i + k >= s.length()) {
                k = s.length() - i;
            }
            for (int j = 0; j < k / 2; j++) {
                swap(s[i + j], s[i + k - 1 - j]);
            }
        }

        return s;
    }
};
```

## [剑指 Offer 05. 替换空格](https://leetcode.cn/problems/ti-huan-kong-ge-lcof/)

### 解法1：题意

$$
O(n)+O(1)
$$

```C++
class Solution {
public:
    string replaceSpace(string s) {        
        string array;
        for (auto c : s) {
            if (c == ' ') {
                array += "%20";
            }
            else {
                array.push_back(c);
            }
        }
        return array;
    }
};
```

## [151. 反转字符串中的单词](https://leetcode.cn/problems/reverse-words-in-a-string/)

### 解法1：双指针

$$
O(n)+O(1)
$$

```C++
class Solution {
public:
    string reverseWords(string s) {
        string new_s;
        int i = 0;
        while (i < s.length()) {
            if (s[i] == ' ') {
                i++;
                continue;
            }
            int j;
            for (j = 0; i + j < s.length(); j++) {
                if (s[i + j] == ' ') {
                    break;
                }
            }
            if (new_s.length() == 0) {
                new_s = s.substr(i, j);
            }
            else {
                new_s = s.substr(i,j) + " " + new_s;
            }
            i += j;
        }

        return new_s;
    }
};
```

## [剑指 Offer 58 - II. 左旋转字符串](https://leetcode.cn/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/)

### 解法1：题意

$$
O(n)+O(1)
$$

```C++
class Solution {
public:
    string reverseLeftWords(string s, int n) {
        s = s.substr(n) + s.substr(0, n);
        return s;
    }
};
```

## ==[28. 找出字符串中第一个匹配项的下标](https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/)==

### 解法1：KMP算法

$$
O(m+n)+O(n)
$$

```C++
class Solution {
public:
    int strStr(string haystack, string needle) {
        int i, j, next[10010] = {-1};
        for (i = 1, j = -1; i < needle.length(); i++) {
            while (j >= 0 && needle[i] != needle[j + 1]) {
                j = next[j];
            }
            if (needle[i] == needle[j + 1]) {
                j++;
            }
            next[i] = j;
        }

        for (i = 0, j = -1; i < haystack.length(); i++) {
            while (j >= 0 && haystack[i] != needle[j + 1]) {
                j = next[j];
            }
            if (haystack[i] == needle[j + 1]) {
                j++;
            }
            if (j == needle.size() - 1) {
                return i - j;
            }
        }

        return -1;
    }
};
```

## ==[459. 重复的子字符串](https://leetcode.cn/problems/repeated-substring-pattern/)==

### 解法1：KMP算法

$$
O(m+n)+O(n)
$$

```C++
class Solution {
public:
    bool repeatedSubstringPattern(string s) {
        string t = s + s;
        t.erase(t.begin()), t.erase(t.end() - 1);
        if (t.find(s) == string::npos) {
            return false;
        }
        return true;
    }
};
```

## -------以下为额外题目-------

## ==[925. 长按键入](https://leetcode.cn/problems/long-pressed-name/)==

### 解法1：双指针

$$
O(m+n)+O(1)
$$

```C++
class Solution {
public:
    bool isLongPressedName(string name, string typed) {
        int i = 0, j = 0;
        while (i < name.size() && j < typed.size()) {
            if (name[i] == typed[j]) { // 相同则同时向后匹配
                i++;
                j++;
            }
            else { // 不相同
                if (j == 0) { // 如果是第一位就不相同直接返回false
                    return false;
                }
                // j跨越重复项，向后移动，同时防止j越界
                while (j < typed.size() && typed[j] == typed[j - 1]) {
                    j++;
                }
                if (name[i] == typed[j]) { // j跨越重复项之后再次和name[i]匹配
                    i++;
                    j++; // 相同则同时向后匹配
                }
                else {
                    return false;
                }
            }
        }
        // 说明name没有匹配完，例如 name:"pyplrzzzzdsfa" type:"ppyypllr"
        if (i < name.size()) {
            return false;
        }

        // 说明type没有匹配完，例如 name:"alex" type:"alexxrrrrssda"
        while (j < typed.size()) {
            if (typed[j] == typed[j - 1]) {
                j++;
            }
            else {
                return false;
            }
        }
        return true;
    }
};
```

# 双指针法

## 均可在上几章找到对应题目

## [27. 移除元素](https://leetcode.cn/problems/remove-element/)

## [26. 删除有序数组中的重复项](https://leetcode.cn/problems/remove-duplicates-from-sorted-array/)

## [283. 移动零](https://leetcode.cn/problems/move-zeroes/)

## [844. 比较含退格的字符串](https://leetcode.cn/problems/backspace-string-compare/)

## [977. 有序数组的平方](https://leetcode.cn/problems/squares-of-a-sorted-array/)

## [344. 反转字符串](https://leetcode.cn/problems/reverse-string/)

## [剑指 Offer 05. 替换空格](https://leetcode.cn/problems/ti-huan-kong-ge-lcof/)

## [151. 反转字符串中的单词](https://leetcode.cn/problems/reverse-words-in-a-string/)

## [206. 反转链表](https://leetcode.cn/problems/reverse-linked-list/)

## [19. 删除链表的倒数第 N 个结点](https://leetcode.cn/problems/remove-nth-node-from-end-of-list/)

## [面试题 02.07. 链表相交](https://leetcode.cn/problems/intersection-of-two-linked-lists-lcci/)

## [142. 环形链表 II](https://leetcode.cn/problems/linked-list-cycle-ii/)

## [15. 三数之和](https://leetcode.cn/problems/3sum/)

## [18. 四数之和](https://leetcode.cn/problems/4sum/)

# 栈与队列

## [232. 用栈实现队列](https://leetcode.cn/problems/implement-queue-using-stacks/)

### 解法1：模拟

$$
O(1)+O(n)
$$

```C++
class MyQueue {
    stack<int> s1, s2;
public:
    MyQueue() {

    }
    
    void push(int x) {
        s2.push(x);
    }
    
    int pop() {
        if (s1.empty()) {
            while (!s2.empty()) {
                s1.push(s2.top());
                s2.pop();
            }
        }
        int x = s1.top();
        s1.pop();
        return x;
    }
    
    int peek() {
        if (s1.empty()) {
            while (!s2.empty()) {
                s1.push(s2.top());
                s2.pop();
            }
        }
        return s1.top();
    }
    
    bool empty() {
        return s1.empty() && s2.empty();
    }
};

/**
 * Your MyQueue object will be instantiated and called as such:
 * MyQueue* obj = new MyQueue();
 * obj->push(x);
 * int param_2 = obj->pop();
 * int param_3 = obj->peek();
 * bool param_4 = obj->empty();
 */
```

## [225. 用队列实现栈](https://leetcode.cn/problems/implement-stack-using-queues/)

### 解法1：模拟

$$
O(n)+O(n)
$$

```C++
class MyStack {
    queue<int> q;
public:
    MyStack() {

    }
    
    void push(int x) {
        q.push(x);
    }
    
    int pop() {
        int k = q.size() - 1;
        while (k--) {
            q.push(q.front()), q.pop();
        }
        int x = q.front();
        q.pop();
        return x;
    }
    
    int top() {
        return q.back();
    }
    
    bool empty() {
        return q.empty();
    }
};

/**
 * Your MyStack object will be instantiated and called as such:
 * MyStack* obj = new MyStack();
 * obj->push(x);
 * int param_2 = obj->pop();
 * int param_3 = obj->top();
 * bool param_4 = obj->empty();
 */
```

## [20. 有效的括号](https://leetcode.cn/problems/valid-parentheses/)

### 解法1：栈

$$
O(n)+O(n)
$$

```C++
class Solution {
public:
    bool isValid(string s) {
        unordered_map<char, char> maps;
        maps['('] = ')', maps['['] = ']', maps['{'] = '}'; //构建映射表
        stack<char> st; //栈
        for (int i = 0; i < s.length(); i++) {
            if (s[i] == '(' || s[i] == '[' || s[i] == '{') { //遇见左括号，入栈
                st.push(s[i]);
            }
            else { //遇见右括号，查看栈顶左括号是否匹配
                if (st.empty() || (maps[st.top()] != s[i])) { //栈空，或栈顶左括号不匹配
                    return false;
                }
                else { //栈顶左括号匹配
                    st.pop();
                }
            }
        }
        if (!st.empty()) { //有左括号未匹配
            return false;
        }
        else {
            return true;
        }
    }
};
```

## ==[1047. 删除字符串中的所有相邻重复项](https://leetcode.cn/problems/remove-all-adjacent-duplicates-in-string/)==

### 解法1：栈

$$
O(n)+O(n)
$$

```C++
class Solution {
public:
    string removeDuplicates(string s) {
        string new_s = ""; // stirng是可以当做stack来用的
        for (auto c: s) {
            if (new_s.empty() || new_s.back() != c) {
                new_s += c;
            }
            else {
                new_s.pop_back();
            }
        }
        
        return new_s;
    }
};
```

## [150. 逆波兰表达式求值](https://leetcode.cn/problems/evaluate-reverse-polish-notation/)

### 解法1：栈

$$
O(n)+O(n)
$$

```C++
class Solution {
public:
    int evalRPN(vector<string>& tokens) {
        stack<int> st;

        for (auto s: tokens) {
            if (s[0] >= '0' && s[0] <= '9') {
                int n = 0;
                for (auto i: s) {
                    n = n * 10 + i - '0';
                }
                st.push(n);
            }
            else if (s[0] == '-' && s.length() > 1) {
                int n = 0;
                s = s.substr(1);
                for (auto i: s) {
                    n = n * 10 + i - '0';
                }
                st.push(-n);
            }
            else {
                int a, b;
                a = st.top(), st.pop();
                b = st.top(), st.pop();
                switch (s[0]) {
                    case '+': b = b + a; break;
                    case '-': b = b - a; break;
                    case '*': b = b * a; break;
                    case '/': b = b / a; break;
                }
                st.push(b);
            }
        }

        return st.top();
    }
};
```

## [239. 滑动窗口最大值](https://leetcode.cn/problems/sliding-window-maximum/)

### 解法1：单调队列

$$
O(n)+O(n)
$$

```C++
class Solution {
public:
    vector<int> maxSlidingWindow(vector<int>& nums, int k) {
        deque<int> q; //双端队列，存位置；双端队列头部永远存的是当前滑动窗口的最大值
        vector<int> result; //存放各滑动窗口的最大值
        
        for (int i = 0; i < nums.size(); i++) {
            //访问 0或i-k+1 到 i 的滑动窗口的数组
            if (!q.empty() && q.front() < i - k + 1) { //若双端队列第一个数的位置不在范围内，将其移出
                q.pop_front();
            }
            while (!q.empty() && nums[q.back()] <= nums[i]) { //当双端队列最后一个数比当前位置的数要小时，则后续滑动窗口继续右移时，滑动窗口内最大的数必然大于等于当前位置的数，故可以直接将双端队列最后的数移出
                q.pop_back();
            }
            q.push_back(i); //将当前位置的数移入双端队列
            if (i >= k - 1) { //当滑动敞口大小为k时，将最大值存入结果数组
                result.push_back(nums[q.front()]);
            }
        }

        return result;
    }
};
```

## ==[347. 前 K 个高频元素](https://leetcode.cn/problems/top-k-frequent-elements/)==

### 解法1：堆

$$
O(n\log k)+O(n)
$$

```C++
class Solution {
public:
    struct cmp { //比较结构体
        bool operator()(const pair<int, int>& pair1, const pair<int, int>& pair2) { //加入const和&
            return pair1.second > pair2.second; //小顶堆写法
        }
    };
    vector<int> topKFrequent(vector<int>& nums, int k) {
        unordered_map<int, int> hash; //哈希表记录每个元素出现的次数
        for (auto num : nums) {
            hash[num]++;
        }
        priority_queue<pair<int, int>, vector<pair<int, int>>, cmp> que; //实现小顶堆
        for (auto item : hash) {
            if (que.size() < k) {
                que.push(item);
            }
            else if (item.second > que.top().second) {
                que.pop();
                que.push(item);
            }
        }
        vector<int> result(k); //取出出现频率前k高的元素
        for (int i = 0; i < k; i++) {
            result[i] = que.top().first;
            que.pop();
        }
        return result;
    }
};
```











# 二叉树







# ==回溯算法==

## [77. 组合](https://leetcode.cn/problems/combinations/)

### 解法1：回溯（组合+剪枝优化）

$$
O(n2^n)+O(n)
$$

```C++
class Solution {
    vector<vector<int>> result;
    vector<int> path;
    void backtracking(int n, int k, int index) {
        if (path.size() == k) {
            result.push_back(path);
            return;
        }
        for (int i = index; i <= n - (k - path.size()) + 1; i++) {
            path.push_back(i);
            backtracking(n, k, i + 1);
            path.pop_back();
        }
    }
public:
    vector<vector<int>> combine(int n, int k) {
        backtracking(n, k, 1);
        return result;
    }
};
```

## [216. 组合总和 III](https://leetcode.cn/problems/combination-sum-iii/)

### 解法1：回溯（组合+剪枝优化）

$$
O(n2^n)+O(n)
$$

```C++
class Solution {
    vector<vector<int>> result;
    vector<int> path;
    void backtracking(int k, int n, int index, int sum) {
        if (path.size() == k) {
            if (sum == n) {
                result.push_back(path);
            }
            return;
        }
        for (int i = index; i <= 9 - (k - path.size()) + 1; i++) {
            if (sum + i > n) {
                break;
            }
            path.push_back(i);
            backtracking(k, n, i + 1, sum + i);
            path.pop_back();
        }
    }
public:
    vector<vector<int>> combinationSum3(int k, int n) {
        backtracking(k, n, 1, 0);
        return result;
    }
};
```

## [17. 电话号码的字母组合](https://leetcode.cn/problems/letter-combinations-of-a-phone-number/)

### 解法1：回溯（组合+多集合）

$$
O(3^m4^n)+O(m+n)
$$

```C++
class Solution {
    const vector<string> letterMap = {
        "", // 0
        "", // 1
        "abc", // 2
        "def", // 3
        "ghi", // 4
        "jkl", // 5
        "mno", // 6
        "pqrs", // 7
        "tuv", // 8
        "wxyz", // 9
    };
    vector<string> result;
    string path;
    void backtracking(const string& digits, int index) {
        if (index == digits.length()) {
            result.push_back(path);
            return;
        }
        for (int i = 0; i < letterMap[digits[index] - '0'].length(); i++) {
            path.push_back(letterMap[digits[index] - '0'][i]);
            backtracking(digits, index + 1);
            path.pop_back();
        }
    }
public:
    vector<string> letterCombinations(string digits) {
        if (digits.length() == 0) {
            return result;
        }
        backtracking(digits, 0);
        return result;
    }
};
```

## [39. 组合总和](https://leetcode.cn/problems/combination-sum/)

### 解法1：回溯（组合+剪枝优化+可重复）

$$
O(n2^n)+O(target)
$$

```C++
class Solution {
    vector<vector<int>> result;
    vector<int> path;
    void backtracking(const vector<int>& candidates, int target, int index, int sum) {
        if (sum == target) {
            result.push_back(path);
            return;
        }
        for (int i = index; i < candidates.size(); i++) {
            if (sum + candidates[i] > target) {
                continue;
            }
            path.push_back(candidates[i]);
            backtracking(candidates, target, i, sum + candidates[i]); //最后一个参数是i而不是i+1，因为元素可以无限制重复被选取
            path.pop_back();
        }
    }
public:
    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {
        backtracking(candidates, target, 0, 0);
        return result;
    }
};
```

## [40. 组合总和 II](https://leetcode.cn/problems/combination-sum-ii/)

### 解法1：回溯（组合+剪枝优化+去重）

$$
O(n2^n)+O(n)
$$

```C++
class Solution {
    vector<vector<int>> result;
    vector<int> path;
    void backtracking(const vector<int>& candidates, int target, int index, int sum, vector<bool>& used) {
        if (sum == target) {
            result.push_back(path);
            return;
        } 
        for (int i = index; i < candidates.size(); i++) {
            if (sum + candidates[i] > target) {
                continue;
            }
            if (i > 0 && candidates[i] == candidates[i - 1] && used[i - 1] == false) { // 该判断语句是去重的核心
                continue;
            }
            path.push_back(candidates[i]);
            used[i] = true;
            backtracking(candidates, target, i + 1, sum + candidates[i], used);
            path.pop_back();
            used[i] = false;
        }
    }
public:
    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {
        sort(candidates.begin(), candidates.end()); // 相比不去重多的第一步：sort
        vector<bool> used(candidates.size(), false); // 相比不去重多的第二步：used
        backtracking(candidates, target, 0, 0, used);
        return result;
    }
};
```

### 解法2：回溯（组合+剪枝优化+去重+优化）

$$
O(n2^n)+O(n)
$$

```C++
class Solution {
    vector<vector<int>> result;
    vector<int> path;
    void backtracking(const vector<int>& candidates, int target, int index, int sum) {
        if (sum == target) {
            result.push_back(path);
            return;
        }
        for (int i = index; i < candidates.size(); i++) {
            if (sum + candidates[i] > target) {
                continue;
            }
            if (i > index && candidates[i] == candidates[i - 1]) {
                continue;
            }
            path.push_back(candidates[i]);
            backtracking(candidates, target, i + 1, sum + candidates[i]);
            path.pop_back();
        }
    }
public:
    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {
        sort(candidates.begin(), candidates.end());
        backtracking(candidates, target, 0, 0);
        return result;
    }
};
```

## [131. 分割回文串](https://leetcode.cn/problems/palindrome-partitioning/)

### 解法1：回溯（分割）

$$
O(n^22^n)+O(n^2)
$$

```C++
class Solution {
    vector<vector<string>> result;
    vector<string> path;
    bool isPalindrome(const string& s, int left, int right) {
        for (int i = left, j = right; i < j; i++, j--) {
            if (s[i] != s[j]) {
                return false;
            }
        }
        return true;
    }
    void backtracking(const string& s, int index) {
        if (index == s.size()) {
            result.push_back(path);
            return;
        }
        for (int i = index; i < s.size(); i++) {
            if (isPalindrome(s, index, i)) {
                path.push_back(s.substr(index, i - index + 1));
                backtracking(s, i + 1);
                path.pop_back();
            }
        }
    }
public:
    vector<vector<string>> partition(string s) {
        backtracking(s, 0);
        return result;
    }
};
```

### 解法2：回溯（分割）+动态规划

$$
O(n2^n)+O(n^2)
$$

```C++
class Solution {
    vector<vector<string>> result;
    vector<string> path;
    vector<vector<bool>> isPalindrome; // 放事先计算好的是否回文子串的结果
    void computePalindrome(const string& s) {
        // isPalindrome[i][j] 代表 s[i:j](双边包括)是否是回文字串 
        isPalindrome.resize(s.size(), vector<bool>(s.size(), false)); // 根据字符串s, 刷新布尔矩阵的大小
        for (int i = s.size() - 1; i >= 0; i--) { 
            // 需要倒序计算, 保证在i行时, i+1行已经计算好了
            for (int j = i; j < s.size(); j++) {
                if (j == i) {
                    isPalindrome[i][j] = true;
                }
                else if (j - i == 1) {
                    isPalindrome[i][j] = (s[i] == s[j]);
                }
                else {
                    isPalindrome[i][j] = (s[i] == s[j] && isPalindrome[i + 1][j - 1]);
                }
            }
        }
    }
    void backtracking(const string& s, int index) {
        if (index == s.size()) {
            result.push_back(path);
            return;
        }
        for (int i = index; i < s.size(); i++) {
            if (isPalindrome[index][i]) {
                path.push_back(s.substr(index, i - index + 1));
                backtracking(s, i + 1);
                path.pop_back();
            }
        }
    }
public:
    vector<vector<string>> partition(string s) {
        computePalindrome(s);
        backtracking(s, 0);
        return result;
    }
};
```

## [93. 复原 IP 地址](https://leetcode.cn/problems/restore-ip-addresses/)

### 解法1：回溯（分割）

$$
略
$$

```C++
class Solution {
public:
    vector<string> result;
    string path;
    int dot_num = 0;
    bool isNum(const string& s, int left, int right) {
        if (left != right && s[left] == '0') {
            return false;
        }
        int sum = 0;
        for (int i = left; i <= right; i++) {
            sum = sum * 10 + s[i] - '0';
            if (sum > 255) {
                return false;
            }
        }
        return true;
    }
    void backtracking(const string &s, int index) {
        if (dot_num == 3) {
            if (index == s.length()) {
                result.push_back(path);
            }
            return;
        }
        for (int i = index; i < s.length(); i++) {
            if (isNum(s, index, i) == false) {
                break;
            }
            string tmp = path;
            if (path.length() != 0) {
                path += '.';
                dot_num++;
            }
            path += s.substr(index, i - index + 1);
            backtracking(s, i + 1);
            path = tmp;
            if (path.length() != 0) {
                dot_num--;
            }
        }
    }
    vector<string> restoreIpAddresses(string s) {
        result.clear(),path.clear();
        backtracking(s, 0);
        return result;
    }
};
```

## [78. 子集](https://leetcode.cn/problems/subsets/)

### 解法1：回溯（集合）

$$
O(n2^n)+O(n)
$$

```C++
class Solution {
public:
    vector<vector<int>> result;
    vector<int> path;
    void backtracking(const vector<int>& nums, int index) {
        result.push_back(path);
        for (int i = index; i < nums.size(); i++) {
            path.push_back(nums[i]);
            backtracking(nums, i + 1);
            path.pop_back();
        }
    }
    vector<vector<int>> subsets(vector<int>& nums) {
        backtracking(nums, 0);
        return result;
    }
};
```

## [90. 子集 II](https://leetcode.cn/problems/subsets-ii/)

### 解法1：回溯（集合+去重）

$$
O(n2^n)+O(n)
$$

```C++
class Solution {
public:
    vector<vector<int>> result;
    vector<int> path;
    void backtracking(const vector<int>& nums, int index, vector<bool>& used) {
        result.push_back(path);
        for (int i = index; i < nums.size(); i++) {
            if (i > 0 && nums[i] == nums[i - 1] && used[i - 1] == false) {
                continue;
            }
            path.push_back(nums[i]);
            used[i] = true;
            backtracking(nums, i + 1, used);
            path.pop_back();
            used[i] = false;
        }
    }
    vector<vector<int>> subsetsWithDup(vector<int>& nums) {
        sort(nums.begin(), nums.end());
        vector<bool> used(nums.size(), false);
        backtracking(nums, 0, used);
        return result;
    }
};
```

### 解法2：回溯（集合+去重+优化）

$$
O(n2^n)+O(n)
$$

```C++
class Solution {
public:
    vector<vector<int>> result;
    vector<int> path;
    void backtracking(const vector<int>& nums, int index) {
        result.push_back(path);
        for (int i = index; i < nums.size(); i++) {
            if (i > index && nums[i] == nums[i - 1]) {
                continue;
            }
            path.push_back(nums[i]);
            backtracking(nums, i + 1);
            path.pop_back();
        }
    }
    vector<vector<int>> subsetsWithDup(vector<int>& nums) {
        sort(nums.begin(), nums.end());
        backtracking(nums, 0);
        return result;
    }
};
```

## [491. 递增子序列](https://leetcode.cn/problems/non-decreasing-subsequences/)

### 解法1：回溯（集合+非排序去重）

$$
O(n2^n)+O(n)
$$

```C++
class Solution {
public:
    vector<vector<int>> result;
    vector<int> path;
    void backtracking(const vector<int>& nums, int index) {
        if (path.size() > 1) {
            result.push_back(path);
        }
        bool used[201] = {false}; // 这里使用数组来进行去重操作，题目说数值范围[-100, 100]；used数组只管同一树层，不管同一树枝
        for (int i = index; i < nums.size(); i++) {
            if (path.size() > 0 && path.back() > nums[i] || used[nums[i] + 100] == true) {
                continue;
            }
            path.push_back(nums[i]);
            used[nums[i] + 100] = true;
            backtracking(nums, i + 1);
            path.pop_back();
        }
    }
    vector<vector<int>> findSubsequences(vector<int>& nums) {
        backtracking(nums, 0);
        return result;
    }
};
```

## [46. 全排列](https://leetcode.cn/problems/permutations/)

### 解法1：回溯（排列）

$$
O(n×n!)+O(n)
$$

```C++
class Solution {
    vector<vector<int>> result;
    vector<int> path;
    void backtracking (vector<int>& nums, vector<bool>& used) {
        if (path.size() == nums.size()) { // 此时说明找到了一组
            result.push_back(path);
            return;
        }
        for (int i = 0; i < nums.size(); i++) {
            if (used[i] == true) { // path里已经收录的元素，直接跳过
                continue;
            }
            used[i] = true;
            path.push_back(nums[i]);
            backtracking(nums, used);
            path.pop_back();
            used[i] = false;
        }
    }
public:
    vector<vector<int>> permute(vector<int>& nums) {
        vector<bool> used(nums.size(), false);
        backtracking(nums, used);
        return result;
    }
};
```

## [47. 全排列 II](https://leetcode.cn/problems/permutations-ii/)

### 解法1：回溯（排列+去重）

$$
O(n)+O(n)
$$

```C++
class Solution {
    vector<vector<int>> result;
    vector<int> path;
    void backtracking (vector<int>& nums, vector<bool>& used) {
        // 此时说明找到了一组
        if (path.size() == nums.size()) {
            result.push_back(path);
            return;
        }
        for (int i = 0; i < nums.size(); i++) {
            // used[i - 1] == true，说明同一树枝nums[i - 1]使用过
            // used[i - 1] == false，说明同一树层nums[i - 1]使用过
            // 如果同一树层nums[i - 1]使用过则直接跳过
            if (i > 0 && nums[i] == nums[i - 1] && used[i - 1] == false) {
                continue;
            }
            if (used[i] == false) {
                used[i] = true;
                path.push_back(nums[i]);
                backtracking(nums, used);
                path.pop_back();
                used[i] = false;
            }
        }
    }
public:
    vector<vector<int>> permuteUnique(vector<int>& nums) {
        sort(nums.begin(), nums.end()); // 排序
        vector<bool> used(nums.size(), false);
        backtracking(nums, used);
        return result;
    }
};
```

## [332. 重新安排行程](https://leetcode.cn/problems/reconstruct-itinerary/)

### 解法1：回溯

$$
略
$$

```C++
class Solution {
    // unordered_map<出发机场, map<到达机场, 航班次数>> targets
    unordered_map<string, map<string, int>> targets;
    bool backtracking(int ticketNum, vector<string>& result) {
        if (result.size() == ticketNum + 1) {
            return true;
        }
        for (pair<const string, int>& target : targets[result.back()]) {
            if (target.second <= 0) { // 记录到达机场是否飞过了
                continue;
            }
            result.push_back(target.first);
            target.second--;
            if (backtracking(ticketNum, result)) {
                return true;
            }
            result.pop_back();
            target.second++;
        }
    return false;
}
public:
    vector<string> findItinerary(vector<vector<string>>& tickets) {
        vector<string> result;
        for (const vector<string>& vec : tickets) {
            targets[vec[0]][vec[1]]++; // 记录映射关系
        }
        result.push_back("JFK"); // 起始机场
        backtracking(tickets.size(), result);
        return result;
    }
};
```

## [51. N 皇后](https://leetcode.cn/problems/n-queens/)

### 解法1：回溯（棋盘）

$$
O(n×n!)+O(n)
$$

```C++
class Solution {
public:
    vector<vector<string>> result;
    vector<string> path;
    vector<bool> visit;
    vector<int> col;
    void backtracking(int index, int n) {
        if (index == n) {
            result.push_back(path);
            return;
        }
        for (int i = 0; i < n; i++) { //[index, i]
            if (visit[i] == false) {
                bool flag = true;
                for (int j = 0; j < index; j++) { //[j, col[j]]
                    if (abs(index - j) == abs(i - col[j])) {
                        flag = false;
                        break;
                    }
                }
                if (flag == true) {
                    visit[i] = true;
                    col[index] = i;
                    string s = "";
                    for (int j = 0; j < n; j++) {
                        if (j == i) {
                            s += 'Q';
                        }
                        else {
                            s +='.';
                        }
                    }
                    path.push_back(s);
                    backtracking(index + 1, n);
                    visit[i] = false;
                    path.pop_back();
                }
            }
        }
    }
    vector<vector<string>> solveNQueens(int n) {
        for (int i = 0; i < n; i++) {
            visit.push_back(false);
            col.push_back(0);
        }
        backtracking(0, n);
        return result;
    }
};
```

## [37. 解数独](https://leetcode.cn/problems/sudoku-solver/)

### 解法1：回溯

$$
略
$$

```C++
class Solution {
    bool isValid(int row, int col, char val, vector<vector<char>>& board) {
        for (int i = 0; i < 9; i++) { // 判断行里是否重复
            if (board[row][i] == val) {
                return false;
            }
        }
        for (int j = 0; j < 9; j++) { // 判断列里是否重复
            if (board[j][col] == val) {
                return false;
            }
        }
        int startRow = (row / 3) * 3;
        int startCol = (col / 3) * 3;
        for (int i = startRow; i < startRow + 3; i++) { // 判断9方格里是否重复
            for (int j = startCol; j < startCol + 3; j++) {
                if (board[i][j] == val ) {
                    return false;
                }
            }
        }
        return true;
    }
    bool backtracking(vector<vector<char>>& board) {
        for (int i = 0; i < board.size(); i++) { // 遍历行
            for (int j = 0; j < board[0].size(); j++) { // 遍历列
                if (board[i][j] != '.') {
                    continue;
                }
                for (char k = '1'; k <= '9'; k++) {
                    if (!isValid(i, j, k, board)) { // (i, j) 这个位置放k是否合适
                        continue;
                    }
                    board[i][j] = k;                // 放置k
                    if (backtracking(board)) {
                        return true; // 如果找到合适一组立刻返回
                    }
                    board[i][j] = '.';              // 回溯，撤销k
                }
                return false;  // 9个数都试完了，都不行，那么就返回false
            }
        }
        return true; // 遍历完没有返回false，说明找到了合适棋盘位置了
    }
public:
    void solveSudoku(vector<vector<char>>& board) {
        backtracking(board);
    }
};
```

## -------以下为额外题目-------

## [52. N 皇后 II](https://leetcode.cn/problems/n-queens-ii/)

### 解法1：回溯

$$
O(n×n!)+O(n)
$$

```C++
class Solution {
    int result = 0;
    vector<bool> visit;
    vector<int> col;
    void backtracking(int index, int n) {
        if (index == n) {
            result++;
            return;
        }
        for (int i = 0; i < n; i++) { //[index, i]
            if (visit[i] == false) {
                bool flag = true;
                for (int j = 0; j < index; j++) { //[j, col[j]]
                    if (abs(index - j) == abs(i - col[j])) {
                        flag = false;
                        break;
                    }
                }
                if (flag == true) {
                    visit[i] = true;
                    col[index] = i;
                    backtracking(index + 1, n);
                    visit[i] = false;
                }
            }
        }
    }
public:
    int totalNQueens(int n) {
        for (int i = 0; i < n; i++) {
            visit.push_back(false);
            col.push_back(0);
        }
        backtracking(0, n);
        return result;
    }
};
```

# 贪心算法

# 动态规划

## 基础知识

动态规划五步曲

1. 确定dp数组（dp table）以及下标的含义
2. 确定递推公式
3. dp数组如何初始化
4. 确定遍历顺序
5. 举例推导dp数组

## 基础部分

### [509. 斐波那契数](https://leetcode.cn/problems/fibonacci-number/)

#### 解法1：动态规划

$$
O(n)+O(n)
$$

```C++
class Solution {
public:
    int fib(int n) {
        int dp[31];
        dp[0]=0,dp[1]=1;
        for(int i=2;i<=n;i++) dp[i]=dp[i-1]+dp[i-2];
        return dp[n];
    }
};
```

#### 解法2：迭代

$$
O(n)+O(1)
$$

```C++
class Solution {
public:
    int fib(int n) {
        int now=0,next=1;
        while(n--){
            int temp=next;
            next=now+next;
            now=temp;
        }
        return now;
    }
};
```

### ==[70. 爬楼梯](https://leetcode.cn/problems/climbing-stairs/)==

#### 解法1：动态规划

$$
O(n)+O(n)
$$

```C++
class Solution {
public:
    int climbStairs(int n) {
        int dp[50];
        dp[0]=1,dp[1]=1;
        for(int i=2;i<=n;i++) dp[i]=dp[i-2]+dp[i-1];
        return dp[n];
    }
};
```

#### 解法2：迭代

$$
O(n)+O(1)
$$

```C++
class Solution {
public:
    int climbStairs(int n) {
        int pre=1,now=1;
        while(--n){
            int temp=now;
            now=now+pre;
            pre=temp;
        }
        return now;
    }
};
```

#### ==拓展：一步最多可以到m个台阶==

$$
O(n)+O(n)
$$

```C++
class Solution {
public:
    int climbStairs(int n) {
        vector<int> dp(n+1,0);
        dp[0]=1;
        for(int i=1;i<=n;i++){
            for(int j=1;j<=m;j++) { // 把m换成2，退化为"爬楼梯"原题
                if(i-j>=0) dp[i]+=dp[i-j];
            }
        }
        return dp[n];
    }
};
```

### [746. 使用最小花费爬楼梯](https://leetcode.cn/problems/min-cost-climbing-stairs/)

#### 解法1：动态规划

$$
O(n)+O(n)
$$

```C++
class Solution {
public:
    int minCostClimbingStairs(vector<int>& cost) {
        int dp[1010];
        dp[0]=0,dp[1]=0;
        for(int i=2;i<=cost.size();i++) dp[i]=min(dp[i-2]+cost[i-2],dp[i-1]+cost[i-1]);
        return dp[cost.size()];
    }
};
```

#### 解法2：动态规划+滚动数组优化

$$
O(n)+O(1)
$$

```C++
class Solution {
public:
    int minCostClimbingStairs(vector<int>& cost) {
        int dp[3];
        dp[0]=0,dp[1]=0;
        for(int i=2;i<=cost.size();i++){
            int temp=dp[1];
            dp[1]=min(dp[0]+cost[i-2],dp[1]+cost[i-1]);
            dp[0]=temp;
        }
        return dp[1];
    }
};
```

### [62. 不同路径](https://leetcode.cn/problems/unique-paths/)

#### 解法1：动态规划

$$
O(mn)+O(mn)
$$

```C++
class Solution {
public:
    int uniquePaths(int m, int n) {
        int dp[110][110];
        for(int i=0;i<=n;i++) dp[0][i]=0;
        for(int i=0;i<=m;i++) dp[i][0]=0;
        dp[1][0]=1;
        for(int i=1;i<=m;i++)
            for(int j=1;j<=n;j++)
                dp[i][j]=dp[i-1][j]+dp[i][j-1];
        return dp[m][n];
    }
};
```

#### 解法2：动态规划+滚动数组优化

$$
O(mn)+O(n)
$$

```C++
class Solution {
public:
    int uniquePaths(int m, int n) {
        vector<int> dp(n+1);
        dp[1]=1;
        for(int i=1;i<=m;i++)
            for(int j=2;j<=n;j++)
                dp[j]=dp[j]+dp[j-1];
        return dp[n];
    }
};
```

### [63. 不同路径 II](https://leetcode.cn/problems/unique-paths-ii/)

#### 解法1：动态规划

$$
O(mn)+O(mn)
$$

```C++
class Solution {
public:
    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {
        int dp[110][110];
        for(int i=0;i<=obstacleGrid[0].size();i++) dp[0][i]=0;
        for(int i=0;i<=obstacleGrid.size();i++) dp[i][0]=0;
        dp[1][0]=1;
        for(int i=1;i<=obstacleGrid.size();i++)
            for(int j=1;j<=obstacleGrid[0].size();j++){
                if(obstacleGrid[i-1][j-1]==0) dp[i][j]=dp[i-1][j]+dp[i][j-1];
                else dp[i][j]=0;
            }
        return dp[obstacleGrid.size()][obstacleGrid[0].size()];
    }
};
```

#### 解法2：动态规划+滚动数组优化

$$
O(mn)+O(n)
$$

```C++
class Solution {
public:
    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {
        int m=obstacleGrid.size(),n=obstacleGrid[0].size();
        vector<int> dp(n+1,0);
        dp[1]=1;
        for(int i=1;i<=m;i++)
            for(int j=1;j<=n;j++){
                if(obstacleGrid[i-1][j-1]==0){
                    if(j==1) continue;
                    else dp[j]=dp[j]+dp[j-1];
                }
                else dp[j]=0;
            }
        return dp[n];
    }
};
```

### [343. 整数拆分](https://leetcode.cn/problems/integer-break/)

#### 解法1：动态规划

$$
O(n)+O(n)
$$

```C++
class Solution {
public:
    int integerBreak(int n) {
        vector<int> dp(n+4);
        dp[2]=1,dp[3]=2;
        for(int i=4;i<=n;i++)
            dp[i]=max(max((i-3)*3,dp[i-3]*3),max((i-2)*2,dp[i-2]*2));
        return dp[n];
    }
};
```

#### 解法2：贪心

$$
O(n)+O(1)
$$

```C++
class Solution {
public:
    int integerBreak(int n) {
        if(n==2) return 1;
        if(n==3) return 2;
        if(n==4) return 4;
        int result=1;
        while(n>4){
            result*=3;
            n-=3;
        }
        result*=n;
        return result;
    }
};
```

### [96. 不同的二叉搜索树](https://leetcode.cn/problems/unique-binary-search-trees/)

#### 解法1：动态规划

$$
O(n^2)+O(n)
$$

```C++
class Solution {
public:
    int numTrees(int n) {
        vector<int> dp(n+1,0);
        dp[0]=1;
        for(int i=1;i<=n;i++){
            for(int j=1;j<=i;j++)
                dp[i]+=dp[j-1]*dp[i-j];
        }
        return dp[n];
    }
};
```

## 01背包问题

### 01背包理论

#### 二维dp数组01背包

1. 确定dp数组以及下标的含义

$dp[i][j]$ 表示从下标为$[0,1,...,i]$的物品里任意取，放进容量为 $j$ 的背包，价值总和最大是多少

<img src="动态规划\01背包问题二维数组.png" alt="01背包问题二维数组" style="zoom:50%;" />

2. 确定递推公式

$dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i])$

3. dp数组如何初始化

首先从$dp[i][j]$ 的定义出发，如果背包容量j为0的话，即$dp[i][0]$ ，无论是选取哪些物品，背包价值总和一定为0。如图：

<img src="动态规划\01背包问题二维数组初始化1.png" alt="01背包问题二维数组初始化1" style="zoom:50%;" />

再看其他情况。

状态转移方程 $dp[i][j]$ = $dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i])$; 可以看出i 是由 i-1 推导出来，那么i为0的时候就一定要初始化。

$dp[0][j]$ ，即：i为0，存放编号0的物品的时候，各个容量的背包所能存放的最大价值。

那么很明显当 j < weight[0]的时候，$dp[0][j]$  应该是 0，因为背包容量比编号0的物品重量还小。

当j >= weight[0]时，$dp[0][j]$  应该是value[0]，因为背包容量放足够放编号0物品。

代码初始化如下：

```C++
for (int j = 0 ; j < weight[0]; j++) {
    dp[0][j] = 0;
}
// 正序遍历
for (int j = weight[0]; j <= bagweight; j++) {
    dp[0][j] = value[0];
}
```

<img src="动态规划\01背包问题二维数组初始化2.png" alt="01背包问题二维数组初始化2" style="zoom:50%;" />

4. 确定遍历顺序

**先遍历物品还是先遍历背包重量呢？其实都可以！ 但是先遍历物品更好理解**。

先遍历物品的代码

```C++
// weight数组的大小 就是物品个数
for(int i = 1; i < weight.size(); i++) { // 遍历物品
    for(int j = 0; j <= bagweight; j++) { // 遍历背包容量
        if (j < weight[i]) dp[i][j] = dp[i - 1][j];
        else dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);
    }
}
```

先遍历背包重量的代码

```C++
// weight数组的大小 就是物品个数
for(int j = 0; j <= bagweight; j++) { // 遍历背包容量
    for(int i = 1; i < weight.size(); i++) { // 遍历物品
        if (j < weight[i]) dp[i][j] = dp[i - 1][j];
        else dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);
    }
}
```

为什么也是可以的呢？

**要理解递归的本质和递推的方向**。

$dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i])$; 递归公式中可以看出是$dp[i][j]$靠$dp[i-1][j]$和$dp[i - 1][j - weight]$推导出来的。

$dp[i-1][j]$和$dp[i - 1][j - weight[i]]$ 都在$dp[i][j]$的左上角方向（包括正上方向），因此先遍历物品和先遍历背包的过程都可以。

5. 举例推导dp数组

略。

#### 一维dp数组（滚动数组）

对于背包问题其实状态都是可以压缩的。

在使用二维数组的时候，递推公式：$dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i])$;

**其实可以发现如果把dp[i - 1]那一层拷贝到dp[i]上，表达式完全可以是：$dp[i][j] = max(dp[i][j], dp[i][j - weight[i]] + value[i])$;**

**与其把dp[i - 1]这一层拷贝到dp[i]上，不如只用一个一维数组了**，只用dp[j]（一维数组，也可以理解是一个滚动数组）。

这就是滚动数组的由来，需要满足的条件是上一层可以重复利用，直接拷贝到当前层。

1. 确定dp数组的定义

在一维dp数组中，dp[j]表示：容量为j的背包，所背的物品价值可以最大为dp[j]。

2. 一维dp数组的递推公式

dp[j]可以通过dp[j - weight[i]]推导出来，dp[j - weight[i]]表示容量为j - weight[i]的背包所背的最大价值。

dp[j - weight[i]] + value[i] 表示 容量为 j - 物品i重量 的背包 加上 物品i的价值。（也就是容量为j的背包，放入物品i了之后的价值即：dp[j]）

此时dp[j]有两个选择，一个是取自己dp[j] 相当于 二维dp数组中的$dp[i-1][j]$，即不放物品i，一个是取dp[j - weight[i]] + value[i]，即放物品i，指定是取最大的，毕竟是求最大价值，

所以递归公式为：$dp[j] = max(dp[j], dp[j - weight[i]] + value[i])$;

3. 一维dp数组如何初始化

dp[j]表示：容量为j的背包，所背的物品价值可以最大为dp[j]，那么dp[0]就应该是0，因为背包容量为0所背的物品的最大价值就是0。

那么dp数组除了下标0的位置，初始为0，其他下标应该初始化多少呢？

看一下递归公式：$dp[j] = max(dp[j], dp[j - weight[i]] + value[i])$;

dp数组在推导的时候一定是取价值最大的数，如果题目给的价值都是正整数那么非0下标都初始化为0就可以了。

**这样才能让dp数组在递归公式的过程中取的最大的价值，而不是被初始值覆盖了**。

那么我假设物品价值都是大于0的，所以dp数组初始化的时候，都初始为0就可以了。

4. 一维dp数组遍历顺序

代码如下：

```C++
for(int i = 0; i < weight.size(); i++) { // 遍历物品
    for(int j = bagWeight; j >= weight[i]; j--) { // 遍历背包容量
        dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);
    }
}
```

**==倒序遍历是为了保证物品i只被放入一次！。但如果一旦正序遍历了，那么物品就会被重复加入多次！==**

**再来看看两个嵌套for循环的顺序，代码中是先遍历物品嵌套遍历背包容量，那可不可以先遍历背包容量嵌套遍历物品呢？**

不可以！

因为一维dp的写法，背包容量一定是要倒序遍历（原因上面已经讲了），如果遍历背包容量放在上一层，那么每个dp[j]就只会放入一个物品，即：背包里只放入了一个物品。

倒序遍历的原因是，本质上还是一个对二维数组的遍历，并且右下角的值依赖上一层左上角的值，因此需要保证左边的值仍然是上一层的，从右向左覆盖。

5. 举例推导dp数组

略。

### [416. 分割等和子集](https://leetcode.cn/problems/partition-equal-subset-sum/)

#### 解法1：动态规划

$$
O(n^2)+O(n)
$$

```C++
class Solution {
public:
    bool canPartition(vector<int>& nums) {
        int sum=0;
        for(int i=0;i<nums.size();i++) sum+=nums[i];
        if(sum%2) return false;
        vector<int> dp(sum/2+1,0);
        for(int i=0;i<nums.size();i++)
            for(int j=sum/2;j>=nums[i];j--)
                dp[j]=max(dp[j],dp[j-nums[i]]+nums[i]);
        if(dp[sum/2]==sum/2) return true;
        else return false;
    }
};
```

### 插曲：补充两道回溯

### [698. 划分为k个相等的子集](https://leetcode.cn/problems/partition-to-k-equal-sum-subsets/)（==待做==）

### [473. 火柴拼正方形](https://leetcode.cn/problems/matchsticks-to-square/)（==待做==）







































### [300. 最长递增子序列](https://leetcode.cn/problems/longest-increasing-subsequence/)

#### 解法1：动态规划

$$
O(n^2)+O(n)
$$

```C++
class Solution {
public:
    int lengthOfLIS(vector<int>& nums) {
        vector<int> d;
        for(int i=0;i<nums.size();i++){
            if(i==0||d[d.size()-1]<nums[i]) d.push_back(nums[i]);
            else{
                int l=0,r=d.size()-1;
                while(l<r){
                    int mid=l+r>>1;
                    if(d[mid]>=nums[i]) r=mid;
                    else l=mid+1;
                }
                d[l]=nums[i];
            }
        }
        return d.size();
    }
};
```

#### 解法2：贪心+二分查找5

$$
O(n\log n)+O(n)
$$

```C++
class Solution {
public:
    int lengthOfLIS(vector<int>& nums) {
        vector<int> d;
        for(int i=0;i<nums.size();i++){
            if(i==0||d[d.size()-1]<nums[i]) d.push_back(nums[i]);
            else{
                int l=0,r=d.size()-1;
                while(l<r){
                    int mid=l+r>>1;
                    if(d[mid]>=nums[i]) r=mid;
                    else l=mid+1;
                }
                d[l]=nums[i];
            }
        }
        return d.size();
    }
};
```

### ==[674. 最长连续递增序列](https://leetcode.cn/problems/longest-continuous-increasing-subsequence/)==

#### 解法1：动态规划

$$
O(n)+O(n)
$$

```C++
class Solution {
public:
    int findLengthOfLCIS(vector<int>& nums) {
        int MAX=1;
        vector<int> dp(nums.size(),1);
        for(int i=1;i<nums.size();i++){
            if(nums[i]>nums[i-1]) dp[i]=dp[i-1]+1;
            MAX=max(dp[i],MAX);
        }
        return MAX;
    }
};
```

#### 解法2：贪心

$$
O(n)+O(1)
$$

```C++
class Solution {
public:
    int findLengthOfLCIS(vector<int>& nums) {
        int MAX=1,now;
        for(int i=0;i<nums.size();i++){
            if(i&&nums[i]>nums[i-1]) now++;
            else now=1;
            MAX=max(MAX,now);
        }
        return MAX;
    }
};
```

#### ==笔记==

注意和上一题的不同，上一题要求子序列，本身没有连续的要求，但本题要求连续子序列，类似于子串



# 单调栈

# 其他

