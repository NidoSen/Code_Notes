# 数组与字符串

## ==[面试题 01.01. 判定字符是否唯一](https://leetcode.cn/problems/is-unique-lcci/)==

### 解法1：位运算

$$
O(n)+O(1)
$$

```C++
class Solution {
public:
    bool isUnique(string astr) {
        int mark = 0; //利用位运算记录字符出现情况，1表示出现，0表示未出现
        for (int i = 0; i < astr.size(); i++) {
            if (mark >> (astr[i] - 'a') & 1) { //查看当前位的字母是否已经出现过
                return false;
            }
            mark += 1 << (astr[i] - 'a'); //标记当前位的字母出现过
        }
        return true;
    }
};
```

## [面试题 01.02. 判定是否互为字符重排](https://leetcode.cn/problems/check-permutation-lcci/)

### 解法1：哈希

$$
O(n)+O(S)
$$

$$
S为字母集大小
$$

```C++
class Solution {
public:
    bool CheckPermutation(string s1, string s2) {
        vector<int> count(26, 0); //标记26个英文字母出现的次数
        for (int i = 0; i < s1.length(); i++) {
            count[s1[i] - 'a']++;
        }
        for (int i = 0; i < s2.length(); i++) {
            count[s2[i] - 'a']--;
        }
        for (int i = 0; i < 26; i++) {
            if (count[i] != 0) {
                return false;
            }
        }
        return true;
    }
};
```

## [面试题 01.03. URL化](https://leetcode.cn/problems/string-to-url-lcci/)

### 解法1：题意

$$
O(n)+O(1)
$$

```C++
class Solution {
public:
    string replaceSpaces(string S, int length) {
        string result;
        for (int i = 0; i < length; i++) {
            if (S[i] != ' ') {
                result += S[i];
            }
            else {
                result += "%20";
            }
        }
        return result;
    }
};
```

## [面试题 01.04. 回文排列](https://leetcode.cn/problems/palindrome-permutation-lcci/)

### 解法1：哈希

$$
O(n)+O(S)
$$

$$
S为字符集大小
$$

```C++
class Solution {
public:
    bool canPermutePalindrome(string s) {
        vector<int> count(128, 0);
        for (int i = 0; i < s.length(); i++) {
            count[s[i]]++;
        }
        int oddNum = 0;
        for (int i = 0; i < 128; i++) {
            if (count[i] % 2 == 1) {
                oddNum++;
                if (oddNum > 1) {
                    return false;
                }
            }
        }
        return true;
    }
};
```

## ==[面试题 01.05. 一次编辑](https://leetcode.cn/problems/one-away-lcci/)==

### 解法1：题意

$$
O(n)+O(1)
$$

```C++
class Solution {
public:
    bool oneEditAway(string first, string second) {
        if (first == second) { //两字符串相等，只需要零次编辑
            return true;
        }
        else if ((int)(first.length() - second.length()) > 1 || (int)(first.length() - second.length()) < -1) { //两字符串相差超过一个字符，不可能在一次编辑内完成；
            return false;
        }
        else {
            int index; //找到第一个不一样的字母
            for (index = 0; index < first.length() && index < second.length(); index++) {
                if (first[index] != second[index]) {
                    break;
                }
            }
            int firstIndex, secondIndex;
            if (first.length() == second.length()) { //两字符串长度相等，则判断是否能替换
                firstIndex = index + 1;
                secondIndex = index + 1;
            }
            else if (first.length() < second.length()) { //firs字符串较短，判断secon能否通过一次删除变成first
                firstIndex = index;
                secondIndex = index + 1;
            }
            else { //firs字符串较长，判断secon能否通过一次插入变成first
                firstIndex = index + 1;
                secondIndex = index;
            }
            for (; firstIndex < first.length(); firstIndex++, secondIndex++) {
                if (first[firstIndex] != second[secondIndex]) {
                    return false;
                }
            }
            return true;
        }
    }
};
```

### ==字符串长度直接相减出现的问题==

本题中发现的一个现象，当first长度为4，second长度为3，运行以下语句，结果为true：

```C++
first.length() - second.length() < -1
```

而当运行以下语句时，结果为false：

```C++
(int)(first.length() - second.length()) < -1
```

## ==[面试题 01.06. 字符串压缩](https://leetcode.cn/problems/compress-string-lcci/)==

### 解法1：题意

$$
O(n)+O(n)
$$

```C++
class Solution {
public:
    string compressString(string S) {
        int count; //记录当前字符的个数
        string result; //记录结果
        for (int i = 0; i < S.length(); i++) {
            if (i == 0) {
                result += S[i];
                count = 1;
            }
            else if (S[i] != S[i - 1]) {
                result += to_string(count); //to_string函数的使用
                result += S[i];
                count = 1;
            }
            else {
                count++;
            }
        }
        result += to_string(count);
        return  result.length() < S.length() ? result : S;
    }
};
```

### ==数字转字符串和字符串转数字==

前者用`to_string`函数，后者用`stoi`函数

## [面试题 01.07. 旋转矩阵](https://leetcode.cn/problems/rotate-matrix-lcci/)

### 解法1：模拟

$$
O(n^2)+O(1)
$$

```C++
class Solution {
public:
    void rotate(vector<vector<int>>& matrix) {
        int n = matrix.size();
        for (int i = 0; i < n / 2; i++) {
            for (int j = i; j < n - 1 - i; j++) { //每次从对角线往右走
                int temp                     = matrix[i][j];
                matrix[i][j]                 = matrix[n - 1 - j][i];
                matrix[n - 1 - j][i]         = matrix[n - 1 - i][n - 1 - j];
                matrix[n - 1 - i][n - 1 - j] = matrix[j][n - 1 - i];
                matrix[j][n - 1 - i]         = temp;
            }
        }
    }
};
```

## [面试题 01.08. 零矩阵](https://leetcode.cn/problems/zero-matrix-lcci/)

### 解法1：模拟

$$
O(mn)+O(1)
$$

```C++
class Solution {
public:
    void setZeroes(vector<vector<int>>& matrix) {
        bool flagRow = false, flagCol = false; //标记第零行和第零列是否有0，通过第零行和第零列标记其他行和列是否有0存在
        int m = matrix.size(), n = matrix[0].size(); //记录行数和列数
        for (int i = 0; i < m; i++) {
            if (matrix[i][0] == 0) { //第零列存在0
                flagCol = true;
                break;
            }
        }
        for (int i = 0; i < n; i++) {
            if (matrix[0][i] == 0) { //第零行存在0
                flagRow = true;
                break;
            }
        }
        for (int i = 1; i < m; i++) {
            for (int j = 1; j < n; j++) { //借助第零行和第零列标记哪行哪列存在零
                if (matrix[i][j] == 0) {
                    matrix[i][0] = matrix[0][j] = 0;
                }
            }
        }
        for (int i = 1; i < m; i++) { //将有零的行和列全部置零
            for (int j = 1; j < n; j++) {
                if (matrix[i][0] == 0 || matrix[0][j] == 0) {
                    matrix[i][j] = 0;
                }
            }
        }
        if (flagCol == true) {
            for (int i = 0; i < m; i++) {
                matrix[i][0] = 0;
            }
        }
        if (flagRow == true) {
            for (int i = 0; i < n; i++) {
                matrix[0][i] = 0;
            }
        }
    }
};
```

## ==[面试题 01.09. 字符串轮转](https://leetcode.cn/problems/string-rotation-lcci/)==

### 解法1：KMP算法

$$
O(n)+O(n)
$$

```C++
class Solution {
public:
    bool isFlipedString(string s1, string s2) {
        if (s1.length() != s2.length()) {
            return false;
        }
        string newS2 = s2 + s2;
        //以下内容也可以用return newS2.find(s1) != string::npos;
        if (s1.length() == 0 && s2.length() == 0) {
            return true;
        }
        /*KMP算法*/
        vector<int> next(s1.length(), -1);
        // 求模式串的next数组：
        for (int i = 1, j = -1; i < s1.length(); i++) {
            while (j >= 0 && s1[i] != s1[j + 1]) {
                j = next[j];
            }
            if (s1[i] == s1[j + 1]) {
                j++;
            }
            next[i] = j;
        }
        // 匹配
        for (int i = 0, j = -1; i < newS2.length(); i++) {
            while (j >= 0 && newS2[i] != s1[j + 1]) {
                j = next[j];
            }
            if (newS2[i] == s1[j + 1]) {
                j++;
            }
            if (j == s1.length() - 1) {
                return true;
            }
        }
        return false;
    }
};
```

```C++
class Solution {
public:
    bool isFlipedString(string s1, string s2) {
        if (s1.length() != s2.length()) {
            return false;
        }
        string newS2 = s2 + s2;
        return newS2.find(s1) != string::npos;
    }
};
```

### ==字符串的find函数==

`find`函数未能找到字符串时，返回的是`stirng::npos`而不是`NULL`

### ==KMP算法模板==

```C++
// s[]是长文本，p[]是模式串，n是s的长度，m是p的长度
// 求模式串的next数组：
vector<int> next(m, -1);
for (int i = 1, j = -1; i < m; i++) {
	while (j >= 0 && p[i] != p[j + 1]) {
		j = next[j];
    }
	if (p[i] == p[j + 1]) {
        j++;
    }
    next[i] = j;
}
// 匹配
for (int i = 0, j = -1; i < n; i++) {
    while (j >= 0 && s[i] != p[j + 1]) {
        j = next[j];
    }
    if (s[i] == p[j + 1]) {
        j++;
    }
    if (j == m - 1) {
        // 匹配成功后的逻辑
    }
}
```

# 链表

## ==[面试题 02.01. 移除重复节点](https://leetcode.cn/problems/remove-duplicate-node-lcci/)==

### 解法1：哈希

$$
O(n)+O(n)
$$

```C++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* removeDuplicateNodes(ListNode* head) {
        ListNode* dummyHead = new ListNode(0); //增加虚拟头节点，统一操作
        unordered_set<int> uset; //记录出现的节点
        dummyHead->next = head;
        ListNode* pre = dummyHead, * cur = head;
        while (cur != NULL) {
            if (uset.find(cur->val) != uset.end()) { //重复节点
                pre->next = cur->next;
                cur = cur->next;
            }
            else { //非重复节点
                uset.insert(cur->val);
                pre = pre->next;
                cur = cur->next;
            }
        }
        return dummyHead->next;
    }
};
```

### ==`unordered_set`常用方法==

1. 容器无序，其中元素可以重复
2. 注意，此容器模板类中没有重载 [ ] 运算符，也没有提供 at() 成员方法。不仅如此，由于 unordered_set 容器内部存储的元素值不能被修改，因此无论使用那个迭代器方法获得的迭代器，都不能用于修改容器中元素的值。

| 成员方法         | 功能                                                         |
| ---------------- | ------------------------------------------------------------ |
| begin()          | 返回指向容器中第一个元素的正向迭代器。                       |
| end();           | 返回指向容器中最后一个元素之后位置的正向迭代器。             |
| empty()          | 若容器为空，则返回 true；否则 false。                        |
| size()           | 返回当前容器中存有元素的个数。                               |
| **find(key)**    | 查找以值为 key 的元素，如果找到，则返回一个指向该元素的正向迭代器；反之，则返回一个指向容器中最后一个元素之后位置的迭代器（即 **end()** ）。 |
| count(key)       | 在容器中查找值为 key 的元素的个数。                          |
| equal_range(key) | 返回一个 pair 对象，其包含 2 个迭代器，用于表明当前容器中值为 key 的元素所在的范围。 |
| emplace_hint()   | 向容器中添加新元素，效率比 insert() 方法高。                 |
| **insert()**     | 向容器中添加新元素。                                         |
| erase()          | 删除指定元素。                                               |
| clear()          | 清空容器，即删除容器中存储的所有元素。                       |

## [面试题 02.02. 返回倒数第 k 个节点](https://leetcode.cn/problems/kth-node-from-end-of-list-lcci/)

### 解法1：双指针

$$
O(n)+O(1)
$$

```C++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    int kthToLast(ListNode* head, int k) {
        ListNode* slow = head, * fast = head;
        while (k--) {
            fast = fast->next;
        }
        while (fast != NULL) {
            slow = slow->next;
            fast = fast->next;
        }
        return slow->val;
    }
};
```

## [面试题 02.03. 删除中间节点](https://leetcode.cn/problems/delete-middle-node-lcci/)

### 解法1：技巧

$$
O(1)+O(1)
$$

```C++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    void deleteNode(ListNode* node) {
        node->val = node->next->val;
        node->next = node->next->next;
    }
};
```

## [面试题 02.04. 分割链表](https://leetcode.cn/problems/partition-list-lcci/)

### 解法1：尾插法

$$
O(n)+O(1)
$$

```C++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* partition(ListNode* head, int x) {
        ListNode* dummyHead1 = new ListNode(0), * dummyHead2 = new ListNode(0);
        dummyHead1->next = head;
        ListNode* pre = dummyHead1, * cur1 = head, * cur2 = dummyHead2;
        while (cur1 != NULL) {
            if (cur1->val >= x) {
                pre->next = cur1->next;
                cur2->next = cur1;
                cur2 = cur1;
                cur2->next = NULL;
                cur1 = pre->next;
            }
            else {
                pre = pre->next;
                cur1 = cur1->next;
            }
        }
        pre->next = dummyHead2->next;
        return dummyHead1->next;
    }
};
```

## [面试题 02.05. 链表求和](https://leetcode.cn/problems/sum-lists-lcci/)

### 解法1：大数加法

$$
O(m+n)+O(1)
$$

```C++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
        ListNode * dummyHead = new ListNode(0), * cur = dummyHead; //虚拟头结点统一操作
        int t = 0; //存储进位
        ListNode * p = l1, * q = l2;
        while (p || q || t) { //遍历l1和l2
            int x = t; //计算当前位的和
            if (p) {
                x += p->val;
                p = p->next;
            }
            if (q) {
                x+= q->val;
                q = q->next;
            }
            t = x / 10; //保留进位
            x = x % 10; //取出当前位；
            ListNode * now = new ListNode(x); //构造当前节点
            cur->next = now; //尾插法
            cur = cur->next;
        }
        return dummyHead->next;
    }
};
```

## ==[面试题 02.06. 回文链表](https://leetcode.cn/problems/palindrome-linked-list-lcci/)==

### 解法1：双指针+头插法

$$
O(n)+O(1)
$$

```C++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    bool isPalindrome(ListNode* head) {
        if (head == NULL || head->next == NULL) {
            return true;
        }
        ListNode* pre = NULL, * slow = head, * fast = head;
        while (fast != NULL && fast->next != NULL) {
            pre = slow;
            slow = slow->next;
            fast = fast->next->next;
        }
        if (fast != NULL){
            //slow和fast均从head出发
            //若fast最终为NULL，则链表结点数为偶数，分[前半段，后半段]，slow位置为后半段链表第一个结点
            //若fast最终不为NULL，则链表结点数为奇数，slow位置为[前半段，中间结点，后半段]，slow位置为中间结点
            slow = slow->next;
        }
        pre->next = NULL;
        ListNode* dummyHead = new ListNode();
        while (slow != NULL) {
            ListNode* p = slow;
            slow = slow->next;
            p->next = dummyHead->next;
            dummyHead->next = p;
        }
        
        ListNode* head1 = head, * head2 = dummyHead->next;
        while (head1 != NULL && head2 != NULL) {
            if (head1->val != head2->val) {
                return false;
            }
            head1 = head1->next;
            head2 = head2->next;
        }
        return true;
    }
};
```

## [面试题 02.07. 链表相交](https://leetcode.cn/problems/intersection-of-two-linked-lists-lcci/)

### 解法1：双指针

$$
O(m+n)+O(1)
$$

```C++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
        ListNode *p = headA, *q = headB; //用于遍历两个单链表
        int m = 0, n = 0; //记录链表A和链表B的结点个数
        while (p != NULL) { //记录链表A的结点个数
            p = p->next;
            m++;
        }
        while (q != NULL) { //记录链表B的结点个数
            q = q->next;
            n++;
        }
        int k; //记录两个链表的结点个数之差
        if (m >= n) { //p重置为个数多的那个链表的头结点，q重置为个数少的那个链表的头结点
            p = headA;
            q = headB;
            k = m - n;
        }
        else {
            p = headB;
            q = headA;
            k = n - m;
        }
        for (int i = 0; i < k; i++) { //p往后移动k个结点，控制p和q离相交节点的结点个数相同
            p = p->next;
        }
        while (p != q) { //向后同步移动p和q，直到二者相遇或同时为NULL
            p = p->next;
            q = q->next;
        }
        return p;
    }
};
```

## ==[面试题 02.08. 环路检测](https://leetcode.cn/problems/linked-list-cycle-lcci/)==

### 解法1：快慢指针

$$
O(n)+O(1)
$$

```C++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode *detectCycle(ListNode *head) {
        if (head == NULL || head->next == NULL) { //节点数少于两个，则无环
            return NULL;
        }

        ListNode* slow = head, * fast = head; //快慢指针均从头节点处出发
        do {
            if (fast == NULL || fast->next == NULL) { //说明是无环单链表
                return NULL;
            }
            slow = slow->next; //慢指针一次走一步
            fast = fast->next->next; //快指针一次走两步
        } while (slow != fast);

        slow = head;
        while (slow != fast) {
            slow = slow->next;
            fast = fast->next;
        }

        return slow; //正常退出循环，说明存在环
    }
};
```

# 栈与队列

## [面试题 03.01. 三合一](https://leetcode.cn/problems/three-in-one-lcci/)

### 解法1：模拟

$$
O(1)+O(n)
$$

```C++
class TripleInOne {
    vector<int> arr, top;
    int stackSize;
public:
    TripleInOne(int stackSize) {
        arr.resize(3 * stackSize);
        top.push_back(0), top.push_back(0), top.push_back(0);
        this->stackSize = stackSize;
    }
    
    void push(int stackNum, int value) {
        if (top[stackNum] == stackSize) {
            return;
        }
        else {
            arr[stackNum * stackSize + top[stackNum]] = value;
            top[stackNum]++;
        }
    }
    
    int pop(int stackNum) {
        if (top[stackNum] == 0) {
            return -1;
        }
        else {
            int result = arr[stackNum * stackSize + top[stackNum] - 1];
            top[stackNum]--;
            return result;
        }
    }
    
    int peek(int stackNum) {
        if (top[stackNum] == 0) {
            return -1;
        }
        else {
            return arr[stackNum * stackSize + top[stackNum] - 1];
        }
    }
    
    bool isEmpty(int stackNum) {
        if (top[stackNum] == 0) {
            return true;
        }
        else {
            return false;
        }
    }
};

/**
 * Your TripleInOne object will be instantiated and called as such:
 * TripleInOne* obj = new TripleInOne(stackSize);
 * obj->push(stackNum,value);
 * int param_2 = obj->pop(stackNum);
 * int param_3 = obj->peek(stackNum);
 * bool param_4 = obj->isEmpty(stackNum);
 */
```

## [面试题 03.02. 栈的最小值](https://leetcode.cn/problems/min-stack-lcci/)

### 解法1：模拟

$$
O(1)+O(n)
$$

```C++
class MinStack {
    stack<int> st,min_st; //分别作为正常的栈和存储最小元素的栈
public:
    MinStack() {
        while (!st.empty()) { //栈非空时将栈清空
            st.pop();
        }
        while (!min_st.empty()) { //最小栈非空时将最小栈清空
            min_st.pop();
        }
    }
    
    void push(int val) {
        st.push(val); //将元素压栈
        if (min_st.empty() || val <= min_st.top()) { //最小栈空或者当前元素比栈顶元素更小，则压入最小栈
            min_st.push(val);
        }
    }
    
    void pop() {
        if (!min_st.empty() && st.top() == min_st.top()) { //最小栈非空且最小栈栈顶元素和栈顶元素相同，则最小栈栈顶元素同时出栈
            min_st.pop();
        }
        if (!st.empty()) { //栈非空，则栈顶元素出栈
            st.pop();
        }
    }
    
    int top() {
        if (!st.empty()) { //访问栈顶元素
            return st.top();
        }
        return -1;
    }
    
    int getMin() {
        if (!min_st.empty()) { //访问栈内最小元素，即最小栈栈顶元素
            return min_st.top();
        }
        return -1;
    }
};

/**
 * Your MinStack object will be instantiated and called as such:
 * MinStack* obj = new MinStack();
 * obj->push(val);
 * obj->pop();
 * int param_3 = obj->top();
 * int param_4 = obj->getMin();
 */
```

## [面试题 03.03. 堆盘子](https://leetcode.cn/problems/stack-of-plates-lcci/)

### 解法1：模拟

$$
O(1)+O(n)
$$

```C++
class StackOfPlates {
    vector<stack<int>> stks;
    int cap;
public:
    StackOfPlates(int cap) {
        this->cap = cap;
    }
    
    void push(int val) {
        if (cap == 0) {
            return;
        }
        if (stks.empty() || stks.back().size() == cap) {
            stks.push_back(stack<int>());
        }
        stks.back().push(val);
    }
    
    int pop() {
        if (cap == 0 || stks.empty()) {
            return -1;
        }
        int result = stks.back().top();
        stks.back().pop();
        if (stks.back().empty()) {
            stks.pop_back();
        }
        return result;
    }
    
    int popAt(int index) {
        if (cap == 0 || stks.empty()) {
            return -1;
        }
        if (index < 0 || index >= stks.size()) {
            return -1;
        }
        int result = stks[index].top();
        stks[index].pop();
        if (stks[index].empty()) {
            stks.erase(stks.begin() + index);
        }
        return result;
    }
};

/**
 * Your StackOfPlates object will be instantiated and called as such:
 * StackOfPlates* obj = new StackOfPlates(cap);
 * obj->push(val);
 * int param_2 = obj->pop();
 * int param_3 = obj->popAt(index);
 */
```

## [面试题 03.04. 化栈为队](https://leetcode.cn/problems/implement-queue-using-stacks-lcci/)

### 解法1：模拟

$$
O(1)+O(n)
$$

```C++
class MyQueue {
    stack<int> stk1, stk2;
public:
    /** Initialize your data structure here. */
    MyQueue() {

    }
    
    /** Push element x to the back of queue. */
    void push(int x) {
        stk2.push(x);
    }
    
    /** Removes the element from in front of queue and returns that element. */
    int pop() {
        int result = peek();
        stk1.pop();
        return result;
    }
    
    /** Get the front element. */
    int peek() {
        if (stk1.empty()) {
            while (!stk2.empty()) {
                stk1.push(stk2.top());
                stk2.pop();
            }
        }
        return stk1.top();
    }
    
    /** Returns whether the queue is empty. */
    bool empty() {
        return stk1.empty() && stk2.empty();
    }
};

/**
 * Your MyQueue object will be instantiated and called as such:
 * MyQueue* obj = new MyQueue();
 * obj->push(x);
 * int param_2 = obj->pop();
 * int param_3 = obj->peek();
 * bool param_4 = obj->empty();
 */
```

## [面试题 03.05. 栈排序](https://leetcode.cn/problems/sort-of-stacks-lcci/)

### 解法1：模拟

$$
O(n)+O(n)
$$

```C++
class SortedStack {
    stack<int> stk, auxStk;
public:
    SortedStack() {

    }
    
    void push(int val) {
        if (stk.empty() || stk.top() >= val) {
            stk.push(val);
        }
        else {
            while (!stk.empty() && stk.top() < val) {
                auxStk.push(stk.top());
                stk.pop();
            }
            stk.push(val);
            while (!auxStk.empty()) {
                stk.push(auxStk.top());
                auxStk.pop();
            }
        }
    }
    
    void pop() {
        if (!stk.empty()) {
            stk.pop();
        }
    }
    
    int peek() {
        if (!stk.empty()) {
            return stk.top();
        }
        else {
            return -1;
        }
    }
    
    bool isEmpty() {
        return stk.empty();
    }
};

/**
 * Your SortedStack object will be instantiated and called as such:
 * SortedStack* obj = new SortedStack();
 * obj->push(val);
 * obj->pop();
 * int param_3 = obj->peek();
 * bool param_4 = obj->isEmpty();
 */
```

## [面试题 03.06. 动物收容所](https://leetcode.cn/problems/animal-shelter-lcci/)

### 解法1：模拟

$$
O(1)+O(n)
$$

```C++
class AnimalShelf {
    queue<vector<int>> dogQue, catQue;
public:
    AnimalShelf() {

    }
    
    void enqueue(vector<int> animal) {
        if (animal[1] == 0) {
            catQue.push(animal);
        }
        else {
            dogQue.push(animal);
        }
    }
    
    vector<int> dequeueAny() {
        if (dogQue.empty()) {
            return dequeueCat();
        }
        else if (catQue.empty()) {
            return dequeueDog();
        }
        else {
            return dogQue.front()[0] < catQue.front()[0] ? dequeueDog() : dequeueCat();
        }
    }
    
    vector<int> dequeueDog() {
        if (dogQue.empty()) {
            return vector<int>{-1, -1};
        }
        else {
            vector<int> result = dogQue.front();
            dogQue.pop();
            return result;
        }
    }
    
    vector<int> dequeueCat() {
        if (catQue.empty()) {
            return vector<int>{-1, -1};
        }
        else {
            vector<int> result = catQue.front();
            catQue.pop();
            return result;
        }
    }
};

/**
 * Your AnimalShelf object will be instantiated and called as such:
 * AnimalShelf* obj = new AnimalShelf();
 * obj->enqueue(animal);
 * vector<int> param_2 = obj->dequeueAny();
 * vector<int> param_3 = obj->dequeueDog();
 * vector<int> param_4 = obj->dequeueCat();
 */
```

# 树与图

## [面试题 04.01. 节点间通路](https://leetcode.cn/problems/route-between-nodes-lcci/)

### 解法1：BFS

$$
略
$$

```C++
class Solution {
public:
    bool findWhetherExistsPath(int n, vector<vector<int>>& graph, int start, int target) {
        vector<vector<int>> g(n);
        for (int i = 0; i < graph.size(); i++) {
            g[graph[i][0]].push_back(graph[i][1]);
        }
        vector<bool> visited(n, false);
        queue<int> que;
        visited[start] = true;
        que.push(start);
        while (!que.empty()) {
            int node = que.front();
            que.pop();
            for (int i = 0; i < g[node].size(); i++) {
                if (g[node][i] == target) {
                    return true;
                }
                if (visited[g[node][i]] == false) {
                    visited[g[node][i]] = true;
                    que.push(g[node][i]);
                }
            }
        }
        return false;
    }
};
```

## [面试题 04.02. 最小高度树](https://leetcode.cn/problems/minimum-height-tree-lcci/)

### 解法1：分治

$$
O(n)+O(\log n)
$$

```C++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    TreeNode* createBST(const vector<int>& nums, int left, int right) {
        if (left > right) {
            return NULL;
        }
        int mid = left + right >> 1;
        TreeNode* root = new TreeNode(nums[mid]);
        root->left = createBST(nums, left, mid - 1);
        root->right = createBST(nums, mid + 1, right);
        return root;
    }
    TreeNode* sortedArrayToBST(vector<int>& nums) {
        TreeNode* root = createBST(nums, 0, nums.size() - 1);
        return root;
    }
};
```

## [面试题 04.03. 特定深度节点链表](https://leetcode.cn/problems/list-of-depth-lcci/)

### 解法1：层序遍历

$$
O(n)+O(n)
$$

```C++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    vector<ListNode*> listOfDepth(TreeNode* tree) {
        vector<ListNode*> result;
        queue<TreeNode*> que;
        que.push(tree);
        while (!que.empty()) {
            int size = que.size();
            ListNode* dummyHead = new ListNode(0), * pre = dummyHead;
            for (int i = 0; i < size; i++) {
                TreeNode* node = que.front();
                que.pop();
                ListNode* newNode = new ListNode(node->val);
                pre->next = newNode;
                pre = pre->next;
                if (node->left) {
                    que.push(node->left);
                }
                if (node->right) {
                    que.push(node->right);
                }
            }
            result.push_back(dummyHead->next);
        }
        return result;
    }
};
```

## [面试题 04.04. 检查平衡性](https://leetcode.cn/problems/check-balance-lcci/)

### 解法1：递归

$$
O(n)+O(n)
$$

```C++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    int getHeight(TreeNode* node){
        if (node == NULL) {
            return 0;
        }
        int leftHeight = getHeight(node->left);
        if (leftHeight == -1) {
            return -1;
        }
        int rightHeight = getHeight(node->right);
        if (rightHeight == -1) {
            return -1;
        }
        if (abs(leftHeight - rightHeight) > 1) {
            return -1;
        }
        else return 1 + max(leftHeight, rightHeight);
    }
    bool isBalanced(TreeNode* root) {
        int result = getHeight(root);
        if (result == -1) {
            return false;
        }
        else {
            return true;
        }
    }
};
```

## [面试题 04.05. 合法二叉搜索树](https://leetcode.cn/problems/legal-binary-search-tree-lcci/)

### 解法1：中序遍历

$$
O(n)+O(n)
$$

```C++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    vector<int> arr;
    void inOrder(TreeNode* node) {
        if (node == NULL) {
            return;
        }
        inOrder(node->left);
        arr.push_back(node->val);
        inOrder(node->right);
    }
    bool isValidBST(TreeNode* root) {
        if (root == NULL) {
            return true;
        }
        inOrder(root);
        for (int i = 1; i < arr.size(); i++) {
            if (arr[i - 1] >= arr[i]) {
                return false;
            }
        }
        return true;
    }
};
```

## [面试题 04.06. 后继者](https://leetcode.cn/problems/successor-lcci/)

### 解法1：中序遍历

$$
O(n)+O(n)
$$

```C++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    TreeNode* next = NULL, * result;
    void reverseInOrder(TreeNode* node, TreeNode* p) {
        if (node == NULL) {
            return;
        }
        if (node->right) {
            reverseInOrder(node->right, p);
        }
        if (node == p) {
            result = next;
        }
        next = node;
        if (node->left) {
            reverseInOrder(node->left, p);
        }
    }
    TreeNode* inorderSuccessor(TreeNode* root, TreeNode* p) {
        reverseInOrder(root, p);
        return result;
    }
};
```

### 解法2：二叉搜索树性质

$$
O(n)+O(1)
$$

```C++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    TreeNode* inorderSuccessor(TreeNode* root, TreeNode* p) {
        if (p->right) {
            TreeNode* successor = p->right;
            while (successor->left) {
                successor = successor->left;
            }
            return successor;
        }
        else {
            TreeNode* node = root, * successor = NULL;
            while (node != p) {
                if (node->val > p->val) {
                    successor = node;
                    node = node->left;
                }
                else {
                    node = node->right;
                }
            }
            return successor;
        }
    }
};
```

## [面试题 04.08. 首个共同祖先](https://leetcode.cn/problems/first-common-ancestor-lcci/)

### 解法1：递归

$$
O(n)+O(n)
$$

```C++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        if (root == NULL) {
            return NULL;
        }
        else if (root == p) {
            return p;
        }
        else if (root == q) {
            return q;
        }
        else {
            TreeNode* left = lowestCommonAncestor(root->left, p ,q);
            TreeNode* right = lowestCommonAncestor(root->right, p, q);
            if (left == NULL) {
                return right;
            }
            else if (right == NULL) {
                return left;
            }
            else {
                return root;
            }
        }
    }
};
```

## [面试题 04.09. 二叉搜索树序列](https://leetcode.cn/problems/bst-sequences-lcci/)

### 解法1：回溯

$$
略
$$

```C++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    deque<TreeNode*> dque;
    vector<vector<int>> result;
    vector<int> temp;
    void traversal() {
        if (dque.empty()) {
            result.push_back(temp);
            return;
        }
        int size = dque.size();
        for (int i = 0; i < size; i++) {
            TreeNode* node = dque.front();
            dque.pop_front();
            temp.push_back(node->val);
            if (node->left) {
                dque.push_back(node->left);
            }
            if (node->right) {
                dque.push_back(node->right);
            }
            traversal();
            if (node->left) {
                dque.pop_back();
            }
            if (node->right) {
                dque.pop_back();
            }
            dque.push_back(node);
            temp.pop_back();
        }
    }
    vector<vector<int>> BSTSequences(TreeNode* root) {
        if (root) {
            dque.push_back(root);
        }
        traversal();
        return result;
    }
};
```

## [面试题 04.10. 检查子树](https://leetcode.cn/problems/check-subtree-lcci/)

### 解法1：递归

$$
O(mn)+O(m+n)
$$

```C++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    bool isEqual(TreeNode* t1, TreeNode* t2) {
        if (t1 == NULL && t2 == NULL) {
            return true;
        }
        else if (t1 == NULL || t2 == NULL) {
            return false;
        }
        else if (t1->val != t2->val) {
            return false;
        }
        else {
            return isEqual(t1->left, t2->left) && isEqual(t1->right, t2->right);
        }
    }
    bool checkSubTree(TreeNode* t1, TreeNode* t2) {
        if (t1 == NULL && t2 == NULL) {
            return true;
        }
        else if (t1 == NULL || t2 == NULL) {
            return false;
        }
        else {
            if (isEqual(t1, t2)) {
                return true;
            }
            return checkSubTree(t1->left, t2) || checkSubTree(t1->right, t2);
        }
    }
};
```

## [面试题 04.12. 求和路径](https://leetcode.cn/problems/paths-with-sum-lcci/)

### 解法1：回溯

$$
O(n)+O(n)
$$

```C++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    int result = 0;
    unordered_map<int, int> hash;
    void traversal(TreeNode* node, int nowSum, int sum) {
        result += hash[nowSum - sum];
        hash[nowSum]++;
        if (node->left == NULL && node->right == NULL) {
            hash[nowSum]--;
            return;
        }
        else {
            if (node->left) {
                traversal(node->left, nowSum + node->left->val, sum);
            }
            if (node->right) {
                traversal(node->right, nowSum + node->right->val, sum);
            }
            hash[nowSum]--;
        }
    }
    int pathSum(TreeNode* root, int sum) {
        if (root == NULL) {
            return 0;
        }
        hash[0] = 1;
        traversal(root, root->val, sum);
        return result;
    }
};
```

# 位操作

## [面试题 05.01. 插入](https://leetcode.cn/problems/insert-into-bits-lcci/)

### 解法1：位运算

$$
O(1)+O(1)
$$

```C++
class Solution {
public:
    int insertBits(int N, int M, int i, int j) {
        if (j == 31) {
            return N % (1 << i) + (M << i);
        }
        else {
            return N - N % (1 << (j + 1)) + N % (1 << i) + (M << i);
        }
    }
};
```

## [面试题 05.02. 二进制数转字符串](https://leetcode.cn/problems/binary-number-to-string-lcci/)

### 解法1：位运算

$$
O(C)+O(C)
$$

```c++
class Solution {
public:
    string printBin(double num) {
        double eps = 1e-6;
        string s = "0.";
        while (abs(num) > eps && s.length() < 32) {
            num *= 2;
            int y = (int)num;
            s += '0' + y;
            num -= y;
        }
        if (s.length() < 32) {
            return s;
        }
        else {
            return "ERROR";
        }
    }
};
```

## [面试题 05.03. 翻转数位](https://leetcode.cn/problems/reverse-bits-lcci/)

### 解法1：位运算+哈希

$$
O(n)+O(c)
$$

```C++
class Solution {
public:
    int reverseBits(int num) {
        vector<int> temp;
        temp.push_back(0);
        for (int i = 0; i < 32; i++) {
            if (num >> i & 1) {
                if (temp.back() >=0) {
                    temp.back()++;
                }
                else {
                    temp.push_back(1);
                }
            }
            else {
                if (temp.back() <= 0) {
                    temp.back()--;
                }
                else {
                    temp.push_back(-1);
                }
            }
        }
        int result = 0;
        for (int i = 0; i < temp.size(); i++) {
            int now = 1;
            if (temp[i] == -1) {
                if (i > 0) {
                    now += temp[i - 1];
                }
                if (i < temp.size() - 1) {
                    now += temp[i + 1];
                }
            }
            else if (temp[i] < -1) {
                if (i > 0) {
                    now = max(now, temp[i - 1] + 1);
                }
                if (i < temp.size() - 1) {
                    now  = max(now, temp[i + 1] + 1);
                }
            }
            else {
                now = max(now, temp[i]);
            }
            result = max(result, now);
        }
        return result;
    }
};
```
### 解法2：位运算
$$
O(n)+O(1)
$$

```C++
class Solution {
public:
    int reverseBits(int num) {
        int cur = 0, insert = 0, result = 0;
        for (int i = 0; i < 32; i++) {
            if (num >> i & 1) {
                cur++;
                insert++;
            }
            else {
                insert = cur + 1;
                cur = 0;
            }
            result = max (result, insert);
        }
        return result;
    }
};
```

## [面试题 05.04. 下一个数](https://leetcode.cn/problems/closed-number-lcci/)

### 解法1：位运算

$$
O(\log n)+O(1)
$$

```C++
class Solution {
public:
    vector<int> findClosedNumbers(int num) {
        vector<int> result(2);
        result[0] = result[1] = -1;
        // 比 num 大的数：从右往左，找到第一个 01 位置，然后把 01 转为 10，右侧剩下的 1 移到右侧的低位，右侧剩下的位清0。
        int zeros = 0;
        for (int i = 0; i < 31; i++) {
            if ((num >> i & 1) == 1) {
                if (i < 30 && (num >> (i + 1) & 1) == 0) {
                    result[0] = ((num >> i + 1) << i + 1) + (1 << i + 1) + (1 << i - zeros) - 1;
                    break;
                }
            }
            else {
                zeros++;
            }
        }
        // 比 num 小的数：从右往左，找到第一个 10 位置，然后把 10 转为 01，右侧剩下的 1 移到右侧的高位，右侧剩下的位置0。
        zeros = 0;
        for (int i = 0; i < 31; i++) {
            if ((num >> i & 1) == 1) {
                if (i > 0 && (num >> (i - 1) & 1) == 0) {
                    result[1] = ((num >> i) << i) - (1 << zeros - 1);
                    break;
                }
            }
            else {
                zeros++;
            }
        }
        return result;
    }
};
```

## [面试题 05.06. 整数转换](https://leetcode.cn/problems/convert-integer-lcci/)

### 解法1：位运算

$$
O(\log n)+O(1)
$$

```C++
class Solution {
public:
    int convertInteger(int A, int B) {
        int count = 0;
        for (int i = 0; i < 32; i++) {
            if ((A >> i & 1) != (B >> i & 1)) {
                count++;
            }
        }
        return count;
    }
};
```

## [面试题 05.07. 配对交换](https://leetcode.cn/problems/exchange-lcci/)

### 解法1：位运算

$$
O(\log n)+O(1)
$$

```C++
class Solution {
public:
    int exchangeBits(int num) {
        for (int i = 0; i < 30; i += 2) {
            int low = num >> i & 1, high = num >> (i + 1) & 1;
            if (low == 1 && high == 0) {
                num += 1 << i;
            }
            else if (low == 0 && high == 1) {
                num -= 1 << i;
            }
        }
        return num;
    }
};
```

## [面试题 05.08. 绘制直线](https://leetcode.cn/problems/draw-line-lcci/)

### 解法1：位运算

$$
O(n)+O(1)
$$

```C++
class Solution {
public:
    vector<int> drawLine(int length, int w, int x1, int x2, int y) {
        vector<int> result(length, 0);
        for (int i = x1; i <= x2; i++) {
            int index = y * w / 32 + i / 32;
            unsigned add = 1;
            result[index] = (int)((unsigned)result[index] + (add << 32 - i % 32 - 1));
        }
        return result;
    }
};
```

# 递归与动态规划

# 排序与查找

# 中等难题

# 高难度题

