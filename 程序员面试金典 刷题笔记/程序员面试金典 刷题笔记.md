# 数组与字符串

## ==[面试题 01.01. 判定字符是否唯一](https://leetcode.cn/problems/is-unique-lcci/)==

### 解法1：位运算

$$
O(n)+O(1)
$$

```C++
class Solution {
public:
    bool isUnique(string astr) {
        int mark = 0; //利用位运算记录字符出现情况，1表示出现，0表示未出现
        for (int i = 0; i < astr.size(); i++) {
            if (mark >> (astr[i] - 'a') & 1) { //查看当前位的字母是否已经出现过
                return false;
            }
            mark += 1 << (astr[i] - 'a'); //标记当前位的字母出现过
        }
        return true;
    }
};
```

## [面试题 01.02. 判定是否互为字符重排](https://leetcode.cn/problems/check-permutation-lcci/)

### 解法1：哈希

$$
O(n)+O(S)
$$

$$
S为字母集大小
$$

```C++
class Solution {
public:
    bool CheckPermutation(string s1, string s2) {
        vector<int> count(26, 0); //标记26个英文字母出现的次数
        for (int i = 0; i < s1.length(); i++) {
            count[s1[i] - 'a']++;
        }
        for (int i = 0; i < s2.length(); i++) {
            count[s2[i] - 'a']--;
        }
        for (int i = 0; i < 26; i++) {
            if (count[i] != 0) {
                return false;
            }
        }
        return true;
    }
};
```

## [面试题 01.03. URL化](https://leetcode.cn/problems/string-to-url-lcci/)

### 解法1：题意

$$
O(n)+O(1)
$$

```C++
class Solution {
public:
    string replaceSpaces(string S, int length) {
        string result;
        for (int i = 0; i < length; i++) {
            if (S[i] != ' ') {
                result += S[i];
            }
            else {
                result += "%20";
            }
        }
        return result;
    }
};
```

## [面试题 01.04. 回文排列](https://leetcode.cn/problems/palindrome-permutation-lcci/)

### 解法1：哈希

$$
O(n)+O(S)
$$

$$
S为字符集大小
$$

```C++
class Solution {
public:
    bool canPermutePalindrome(string s) {
        vector<int> count(128, 0);
        for (int i = 0; i < s.length(); i++) {
            count[s[i]]++;
        }
        int oddNum = 0;
        for (int i = 0; i < 128; i++) {
            if (count[i] % 2 == 1) {
                oddNum++;
                if (oddNum > 1) {
                    return false;
                }
            }
        }
        return true;
    }
};
```

## ==[面试题 01.05. 一次编辑](https://leetcode.cn/problems/one-away-lcci/)==

### 解法1：题意

$$
O(n)+O(1)
$$

```C++
class Solution {
public:
    bool oneEditAway(string first, string second) {
        if (first == second) { //两字符串相等，只需要零次编辑
            return true;
        }
        else if ((int)(first.length() - second.length()) > 1 || (int)(first.length() - second.length()) < -1) { //两字符串相差超过一个字符，不可能在一次编辑内完成；
            return false;
        }
        else {
            int index; //找到第一个不一样的字母
            for (index = 0; index < first.length() && index < second.length(); index++) {
                if (first[index] != second[index]) {
                    break;
                }
            }
            int firstIndex, secondIndex;
            if (first.length() == second.length()) { //两字符串长度相等，则判断是否能替换
                firstIndex = index + 1;
                secondIndex = index + 1;
            }
            else if (first.length() < second.length()) { //firs字符串较短，判断secon能否通过一次删除变成first
                firstIndex = index;
                secondIndex = index + 1;
            }
            else { //firs字符串较长，判断secon能否通过一次插入变成first
                firstIndex = index + 1;
                secondIndex = index;
            }
            for (; firstIndex < first.length(); firstIndex++, secondIndex++) {
                if (first[firstIndex] != second[secondIndex]) {
                    return false;
                }
            }
            return true;
        }
    }
};
```

### ==字符串长度直接相减出现的问题==

本题中发现的一个现象，当first长度为4，second长度为3，运行以下语句，结果为true：

```C++
first.length() - second.length() < -1
```

而当运行以下语句时，结果为false：

```C++
(int)(first.length() - second.length()) < -1
```

## ==[面试题 01.06. 字符串压缩](https://leetcode.cn/problems/compress-string-lcci/)==

### 解法1：题意

$$
O(n)+O(n)
$$

```C++
class Solution {
public:
    string compressString(string S) {
        int count; //记录当前字符的个数
        string result; //记录结果
        for (int i = 0; i < S.length(); i++) {
            if (i == 0) {
                result += S[i];
                count = 1;
            }
            else if (S[i] != S[i - 1]) {
                result += to_string(count); //to_string函数的使用
                result += S[i];
                count = 1;
            }
            else {
                count++;
            }
        }
        result += to_string(count);
        return  result.length() < S.length() ? result : S;
    }
};
```

### ==数字转字符串和字符串转数字==

前者用`to_string`函数，后者用`stoi`函数

## [面试题 01.07. 旋转矩阵](https://leetcode.cn/problems/rotate-matrix-lcci/)

### 解法1：模拟

$$
O(n^2)+O(1)
$$

```C++
class Solution {
public:
    void rotate(vector<vector<int>>& matrix) {
        int n = matrix.size();
        for (int i = 0; i < n / 2; i++) {
            for (int j = i; j < n - 1 - i; j++) { //每次从对角线往右走
                int temp                     = matrix[i][j];
                matrix[i][j]                 = matrix[n - 1 - j][i];
                matrix[n - 1 - j][i]         = matrix[n - 1 - i][n - 1 - j];
                matrix[n - 1 - i][n - 1 - j] = matrix[j][n - 1 - i];
                matrix[j][n - 1 - i]         = temp;
            }
        }
    }
};
```

## [面试题 01.08. 零矩阵](https://leetcode.cn/problems/zero-matrix-lcci/)

### 解法1：模拟

$$
O(mn)+O(1)
$$

```C++
class Solution {
public:
    void setZeroes(vector<vector<int>>& matrix) {
        bool flagRow = false, flagCol = false; //标记第零行和第零列是否有0，通过第零行和第零列标记其他行和列是否有0存在
        int m = matrix.size(), n = matrix[0].size(); //记录行数和列数
        for (int i = 0; i < m; i++) {
            if (matrix[i][0] == 0) { //第零列存在0
                flagCol = true;
                break;
            }
        }
        for (int i = 0; i < n; i++) {
            if (matrix[0][i] == 0) { //第零行存在0
                flagRow = true;
                break;
            }
        }
        for (int i = 1; i < m; i++) {
            for (int j = 1; j < n; j++) { //借助第零行和第零列标记哪行哪列存在零
                if (matrix[i][j] == 0) {
                    matrix[i][0] = matrix[0][j] = 0;
                }
            }
        }
        for (int i = 1; i < m; i++) { //将有零的行和列全部置零
            for (int j = 1; j < n; j++) {
                if (matrix[i][0] == 0 || matrix[0][j] == 0) {
                    matrix[i][j] = 0;
                }
            }
        }
        if (flagCol == true) {
            for (int i = 0; i < m; i++) {
                matrix[i][0] = 0;
            }
        }
        if (flagRow == true) {
            for (int i = 0; i < n; i++) {
                matrix[0][i] = 0;
            }
        }
    }
};
```

## ==[面试题 01.09. 字符串轮转](https://leetcode.cn/problems/string-rotation-lcci/)==

### 解法1：KMP算法

$$
O(n)+O(n)
$$

```C++
class Solution {
public:
    bool isFlipedString(string s1, string s2) {
        if (s1.length() != s2.length()) {
            return false;
        }
        string newS2 = s2 + s2;
        //以下内容也可以用return newS2.find(s1) != string::npos;
        if (s1.length() == 0 && s2.length() == 0) {
            return true;
        }
        /*KMP算法*/
        vector<int> next(s1.length(), -1);
        // 求模式串的next数组：
        for (int i = 1, j = -1; i < s1.length(); i++) {
            while (j >= 0 && s1[i] != s1[j + 1]) {
                j = next[j];
            }
            if (s1[i] == s1[j + 1]) {
                j++;
            }
            next[i] = j;
        }
        // 匹配
        for (int i = 0, j = -1; i < newS2.length(); i++) {
            while (j >= 0 && newS2[i] != s1[j + 1]) {
                j = next[j];
            }
            if (newS2[i] == s1[j + 1]) {
                j++;
            }
            if (j == s1.length() - 1) {
                return true;
            }
        }
        return false;
    }
};
```

```C++
class Solution {
public:
    bool isFlipedString(string s1, string s2) {
        if (s1.length() != s2.length()) {
            return false;
        }
        string newS2 = s2 + s2;
        return newS2.find(s1) != string::npos;
    }
};
```

### ==字符串的find函数==

`find`函数未能找到字符串时，返回的是`stirng::npos`而不是`null`

### ==KMP算法模板==

```C++
// s[]是长文本，p[]是模式串，n是s的长度，m是p的长度
// 求模式串的next数组：
vector<int> next(m, -1);
for (int i = 1, j = -1; i < m; i++) {
	while (j >= 0 && p[i] != p[j + 1]) {
		j = next[j];
    }
	if (p[i] == p[j + 1]) {
        j++;
    }
    next[i] = j;
}
// 匹配
for (int i = 0, j = -1; i < n; i++) {
    while (j >= 0 && s[i] != p[j + 1]) {
        j = next[j];
    }
    if (s[i] == p[j + 1]) {
        j++;
    }
    if (j == m - 1) {
        j = ne[j];
        // 匹配成功后的逻辑
    }
}
```

# 链表

