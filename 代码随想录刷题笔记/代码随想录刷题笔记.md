# 动态规划

## 基础知识

动态规划五步曲

1. 确定dp数组（dp table）以及下标的含义
2. 确定递推公式
3. dp数组如何初始化
4. 确定遍历顺序
5. 举例推导dp数组

## 基础部分

### [509. 斐波那契数](https://leetcode.cn/problems/fibonacci-number/)

#### 解法1：动态规划

$$
O(n)+O(n)
$$

```C++
class Solution {
public:
    int fib(int n) {
        int dp[31];
        dp[0]=0,dp[1]=1;
        for(int i=2;i<=n;i++) dp[i]=dp[i-1]+dp[i-2];
        return dp[n];
    }
};
```

#### 解法2：迭代

$$
O(n)+O(1)
$$

```C++
class Solution {
public:
    int fib(int n) {
        int now=0,next=1;
        while(n--){
            int temp=next;
            next=now+next;
            now=temp;
        }
        return now;
    }
};
```

### ==[70. 爬楼梯](https://leetcode.cn/problems/climbing-stairs/)==

#### 解法1：动态规划

$$
O(n)+O(n)
$$

```C++
class Solution {
public:
    int climbStairs(int n) {
        int dp[50];
        dp[0]=1,dp[1]=1;
        for(int i=2;i<=n;i++) dp[i]=dp[i-2]+dp[i-1];
        return dp[n];
    }
};
```

#### 解法2：迭代

$$
O(n)+O(1)
$$

```C++
class Solution {
public:
    int climbStairs(int n) {
        int pre=1,now=1;
        while(--n){
            int temp=now;
            now=now+pre;
            pre=temp;
        }
        return now;
    }
};
```

#### ==拓展：一步最多可以到m个台阶==

$$
O(n)+O(n)
$$

```C++
class Solution {
public:
    int climbStairs(int n) {
        vector<int> dp(n+1,0);
        dp[0]=1;
        for(int i=1;i<=n;i++){
            for(int j=1;j<=m;j++) { // 把m换成2，退化为"爬楼梯"原题
                if(i-j>=0) dp[i]+=dp[i-j];
            }
        }
        return dp[n];
    }
};
```

### [746. 使用最小花费爬楼梯](https://leetcode.cn/problems/min-cost-climbing-stairs/)

#### 解法1：动态规划

$$
O(n)+O(n)
$$

```C++
class Solution {
public:
    int minCostClimbingStairs(vector<int>& cost) {
        int dp[1010];
        dp[0]=0,dp[1]=0;
        for(int i=2;i<=cost.size();i++) dp[i]=min(dp[i-2]+cost[i-2],dp[i-1]+cost[i-1]);
        return dp[cost.size()];
    }
};
```

#### 解法2：动态规划+滚动数组优化

$$
O(n)+O(1)
$$

```C++
class Solution {
public:
    int minCostClimbingStairs(vector<int>& cost) {
        int dp[3];
        dp[0]=0,dp[1]=0;
        for(int i=2;i<=cost.size();i++){
            int temp=dp[1];
            dp[1]=min(dp[0]+cost[i-2],dp[1]+cost[i-1]);
            dp[0]=temp;
        }
        return dp[1];
    }
};
```

### [62. 不同路径](https://leetcode.cn/problems/unique-paths/)

#### 解法1：动态规划

$$
O(mn)+O(mn)
$$

```C++
class Solution {
public:
    int uniquePaths(int m, int n) {
        int dp[110][110];
        for(int i=0;i<=n;i++) dp[0][i]=0;
        for(int i=0;i<=m;i++) dp[i][0]=0;
        dp[1][0]=1;
        for(int i=1;i<=m;i++)
            for(int j=1;j<=n;j++)
                dp[i][j]=dp[i-1][j]+dp[i][j-1];
        return dp[m][n];
    }
};
```

#### 解法2：动态规划+滚动数组优化

$$
O(mn)+O(n)
$$

```C++
class Solution {
public:
    int uniquePaths(int m, int n) {
        vector<int> dp(n+1);
        dp[1]=1;
        for(int i=1;i<=m;i++)
            for(int j=2;j<=n;j++)
                dp[j]=dp[j]+dp[j-1];
        return dp[n];
    }
};
```

### [63. 不同路径 II](https://leetcode.cn/problems/unique-paths-ii/)

#### 解法1：动态规划

$$
O(mn)+O(mn)
$$

```C++
class Solution {
public:
    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {
        int dp[110][110];
        for(int i=0;i<=obstacleGrid[0].size();i++) dp[0][i]=0;
        for(int i=0;i<=obstacleGrid.size();i++) dp[i][0]=0;
        dp[1][0]=1;
        for(int i=1;i<=obstacleGrid.size();i++)
            for(int j=1;j<=obstacleGrid[0].size();j++){
                if(obstacleGrid[i-1][j-1]==0) dp[i][j]=dp[i-1][j]+dp[i][j-1];
                else dp[i][j]=0;
            }
        return dp[obstacleGrid.size()][obstacleGrid[0].size()];
    }
};
```

#### 解法2：动态规划+滚动数组优化

$$
O(mn)+O(n)
$$

```C++
class Solution {
public:
    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {
        int m=obstacleGrid.size(),n=obstacleGrid[0].size();
        vector<int> dp(n+1,0);
        dp[1]=1;
        for(int i=1;i<=m;i++)
            for(int j=1;j<=n;j++){
                if(obstacleGrid[i-1][j-1]==0){
                    if(j==1) continue;
                    else dp[j]=dp[j]+dp[j-1];
                }
                else dp[j]=0;
            }
        return dp[n];
    }
};
```

### [343. 整数拆分](https://leetcode.cn/problems/integer-break/)

#### 解法1：动态规划

$$
O(n)+O(n)
$$

```C++
class Solution {
public:
    int integerBreak(int n) {
        vector<int> dp(n+4);
        dp[2]=1,dp[3]=2;
        for(int i=4;i<=n;i++)
            dp[i]=max(max((i-3)*3,dp[i-3]*3),max((i-2)*2,dp[i-2]*2));
        return dp[n];
    }
};
```

#### 解法2：贪心

$$
O(n)+O(1)
$$

```C++
class Solution {
public:
    int integerBreak(int n) {
        if(n==2) return 1;
        if(n==3) return 2;
        if(n==4) return 4;
        int result=1;
        while(n>4){
            result*=3;
            n-=3;
        }
        result*=n;
        return result;
    }
};
```

















### [300. 最长递增子序列](https://leetcode.cn/problems/longest-increasing-subsequence/)

#### 解法1：动态规划

$$
O(n^2)+O(n)
$$

```C++
class Solution {
public:
    int lengthOfLIS(vector<int>& nums) {
        vector<int> d;
        for(int i=0;i<nums.size();i++){
            if(i==0||d[d.size()-1]<nums[i]) d.push_back(nums[i]);
            else{
                int l=0,r=d.size()-1;
                while(l<r){
                    int mid=l+r>>1;
                    if(d[mid]>=nums[i]) r=mid;
                    else l=mid+1;
                }
                d[l]=nums[i];
            }
        }
        return d.size();
    }
};
```

#### 解法2：贪心+二分查找

$$
O(n\log n)+O(n)
$$

```C++
class Solution {
public:
    int lengthOfLIS(vector<int>& nums) {
        vector<int> d;
        for(int i=0;i<nums.size();i++){
            if(i==0||d[d.size()-1]<nums[i]) d.push_back(nums[i]);
            else{
                int l=0,r=d.size()-1;
                while(l<r){
                    int mid=l+r>>1;
                    if(d[mid]>=nums[i]) r=mid;
                    else l=mid+1;
                }
                d[l]=nums[i];
            }
        }
        return d.size();
    }
};
```

### ==[674. 最长连续递增序列](https://leetcode.cn/problems/longest-continuous-increasing-subsequence/)==

#### 解法1：动态规划

$$
O(n)+O(n)
$$

```C++
class Solution {
public:
    int findLengthOfLCIS(vector<int>& nums) {
        int MAX=1;
        vector<int> dp(nums.size(),1);
        for(int i=1;i<nums.size();i++){
            if(nums[i]>nums[i-1]) dp[i]=dp[i-1]+1;
            MAX=max(dp[i],MAX);
        }
        return MAX;
    }
};
```

#### 解法2：贪心

$$
O(n)+O(1)
$$

```C++
class Solution {
public:
    int findLengthOfLCIS(vector<int>& nums) {
        int MAX=1,now;
        for(int i=0;i<nums.size();i++){
            if(i&&nums[i]>nums[i-1]) now++;
            else now=1;
            MAX=max(MAX,now);
        }
        return MAX;
    }
};
```

#### ==笔记==

注意和上一题的不同，上一题要求子序列，本身没有连续的要求，但本题要求连续子序列，类似于子串



