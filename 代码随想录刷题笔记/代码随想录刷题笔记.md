# 动态规划

## [300. 最长递增子序列](https://leetcode.cn/problems/longest-increasing-subsequence/)

### 解法1：动态规划

$$
O(n^2)+O(n)
$$

```C++
class Solution {
public:
    int lengthOfLIS(vector<int>& nums) {
        vector<int> d;
        for(int i=0;i<nums.size();i++){
            if(i==0||d[d.size()-1]<nums[i]) d.push_back(nums[i]);
            else{
                int l=0,r=d.size()-1;
                while(l<r){
                    int mid=l+r>>1;
                    if(d[mid]>=nums[i]) r=mid;
                    else l=mid+1;
                }
                d[l]=nums[i];
            }
        }
        return d.size();
    }
};
```

### 解法2：贪心+二分查找

$$
O(n\log n)+O(n)
$$

```C++
class Solution {
public:
    int lengthOfLIS(vector<int>& nums) {
        vector<int> d;
        for(int i=0;i<nums.size();i++){
            if(i==0||d[d.size()-1]<nums[i]) d.push_back(nums[i]);
            else{
                int l=0,r=d.size()-1;
                while(l<r){
                    int mid=l+r>>1;
                    if(d[mid]>=nums[i]) r=mid;
                    else l=mid+1;
                }
                d[l]=nums[i];
            }
        }
        return d.size();
    }
};
```

## ==[674. 最长连续递增序列](https://leetcode.cn/problems/longest-continuous-increasing-subsequence/)==

### 解法1：动态规划

$$
O(n)+O(n)
$$

```C++
class Solution {
public:
    int findLengthOfLCIS(vector<int>& nums) {
        int MAX=1;
        vector<int> dp(nums.size(),1);
        for(int i=1;i<nums.size();i++){
            if(nums[i]>nums[i-1]) dp[i]=dp[i-1]+1;
            MAX=max(dp[i],MAX);
        }
        return MAX;
    }
};
```

### 解法2：贪心

$$
O(n)+O(1)
$$

```C++
class Solution {
public:
    int findLengthOfLCIS(vector<int>& nums) {
        int MAX=1,now;
        for(int i=0;i<nums.size();i++){
            if(i&&nums[i]>nums[i-1]) now++;
            else now=1;
            MAX=max(MAX,now);
        }
        return MAX;
    }
};
```

### ==笔记==

注意和上一题的不同，上一题要求子序列，本身没有连续的要求，但本题要求连续子序列，类似于子串



