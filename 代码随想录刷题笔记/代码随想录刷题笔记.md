# 动态规划

## 基础知识

动态规划五步曲

1. 确定dp数组（dp table）以及下标的含义
2. 确定递推公式
3. dp数组如何初始化
4. 确定遍历顺序
5. 举例推导dp数组

## 基础部分

### [509. 斐波那契数](https://leetcode.cn/problems/fibonacci-number/)

#### 解法1：动态规划

$$
O(n)+O(n)
$$

```C++
class Solution {
public:
    int fib(int n) {
        int dp[31];
        dp[0]=0,dp[1]=1;
        for(int i=2;i<=n;i++) dp[i]=dp[i-1]+dp[i-2];
        return dp[n];
    }
};
```

#### 解法2：迭代

$$
O(n)+O(1)
$$

```C++
class Solution {
public:
    int fib(int n) {
        int now=0,next=1;
        while(n--){
            int temp=next;
            next=now+next;
            now=temp;
        }
        return now;
    }
};
```

### ==[70. 爬楼梯](https://leetcode.cn/problems/climbing-stairs/)==

#### 解法1：动态规划

$$
O(n)+O(n)
$$

```C++
class Solution {
public:
    int climbStairs(int n) {
        int dp[50];
        dp[0]=1,dp[1]=1;
        for(int i=2;i<=n;i++) dp[i]=dp[i-2]+dp[i-1];
        return dp[n];
    }
};
```

#### 解法2：迭代

$$
O(n)+O(1)
$$

```C++
class Solution {
public:
    int climbStairs(int n) {
        int pre=1,now=1;
        while(--n){
            int temp=now;
            now=now+pre;
            pre=temp;
        }
        return now;
    }
};
```

#### ==拓展：一步最多可以到m个台阶==

$$
O(n)+O(n)
$$

```C++
class Solution {
public:
    int climbStairs(int n) {
        vector<int> dp(n+1,0);
        dp[0]=1;
        for(int i=1;i<=n;i++){
            for(int j=1;j<=m;j++) { // 把m换成2，退化为"爬楼梯"原题
                if(i-j>=0) dp[i]+=dp[i-j];
            }
        }
        return dp[n];
    }
};
```

### [746. 使用最小花费爬楼梯](https://leetcode.cn/problems/min-cost-climbing-stairs/)

#### 解法1：动态规划

$$
O(n)+O(n)
$$

```C++
class Solution {
public:
    int minCostClimbingStairs(vector<int>& cost) {
        int dp[1010];
        dp[0]=0,dp[1]=0;
        for(int i=2;i<=cost.size();i++) dp[i]=min(dp[i-2]+cost[i-2],dp[i-1]+cost[i-1]);
        return dp[cost.size()];
    }
};
```

#### 解法2：动态规划+滚动数组优化

$$
O(n)+O(1)
$$

```C++
class Solution {
public:
    int minCostClimbingStairs(vector<int>& cost) {
        int dp[3];
        dp[0]=0,dp[1]=0;
        for(int i=2;i<=cost.size();i++){
            int temp=dp[1];
            dp[1]=min(dp[0]+cost[i-2],dp[1]+cost[i-1]);
            dp[0]=temp;
        }
        return dp[1];
    }
};
```

### [62. 不同路径](https://leetcode.cn/problems/unique-paths/)

#### 解法1：动态规划

$$
O(mn)+O(mn)
$$

```C++
class Solution {
public:
    int uniquePaths(int m, int n) {
        int dp[110][110];
        for(int i=0;i<=n;i++) dp[0][i]=0;
        for(int i=0;i<=m;i++) dp[i][0]=0;
        dp[1][0]=1;
        for(int i=1;i<=m;i++)
            for(int j=1;j<=n;j++)
                dp[i][j]=dp[i-1][j]+dp[i][j-1];
        return dp[m][n];
    }
};
```

#### 解法2：动态规划+滚动数组优化

$$
O(mn)+O(n)
$$

```C++
class Solution {
public:
    int uniquePaths(int m, int n) {
        vector<int> dp(n+1);
        dp[1]=1;
        for(int i=1;i<=m;i++)
            for(int j=2;j<=n;j++)
                dp[j]=dp[j]+dp[j-1];
        return dp[n];
    }
};
```

### [63. 不同路径 II](https://leetcode.cn/problems/unique-paths-ii/)

#### 解法1：动态规划

$$
O(mn)+O(mn)
$$

```C++
class Solution {
public:
    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {
        int dp[110][110];
        for(int i=0;i<=obstacleGrid[0].size();i++) dp[0][i]=0;
        for(int i=0;i<=obstacleGrid.size();i++) dp[i][0]=0;
        dp[1][0]=1;
        for(int i=1;i<=obstacleGrid.size();i++)
            for(int j=1;j<=obstacleGrid[0].size();j++){
                if(obstacleGrid[i-1][j-1]==0) dp[i][j]=dp[i-1][j]+dp[i][j-1];
                else dp[i][j]=0;
            }
        return dp[obstacleGrid.size()][obstacleGrid[0].size()];
    }
};
```

#### 解法2：动态规划+滚动数组优化

$$
O(mn)+O(n)
$$

```C++
class Solution {
public:
    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {
        int m=obstacleGrid.size(),n=obstacleGrid[0].size();
        vector<int> dp(n+1,0);
        dp[1]=1;
        for(int i=1;i<=m;i++)
            for(int j=1;j<=n;j++){
                if(obstacleGrid[i-1][j-1]==0){
                    if(j==1) continue;
                    else dp[j]=dp[j]+dp[j-1];
                }
                else dp[j]=0;
            }
        return dp[n];
    }
};
```

### [343. 整数拆分](https://leetcode.cn/problems/integer-break/)

#### 解法1：动态规划

$$
O(n)+O(n)
$$

```C++
class Solution {
public:
    int integerBreak(int n) {
        vector<int> dp(n+4);
        dp[2]=1,dp[3]=2;
        for(int i=4;i<=n;i++)
            dp[i]=max(max((i-3)*3,dp[i-3]*3),max((i-2)*2,dp[i-2]*2));
        return dp[n];
    }
};
```

#### 解法2：贪心

$$
O(n)+O(1)
$$

```C++
class Solution {
public:
    int integerBreak(int n) {
        if(n==2) return 1;
        if(n==3) return 2;
        if(n==4) return 4;
        int result=1;
        while(n>4){
            result*=3;
            n-=3;
        }
        result*=n;
        return result;
    }
};
```

### [96. 不同的二叉搜索树](https://leetcode.cn/problems/unique-binary-search-trees/)

#### 解法1：动态规划

$$
O(n^2)+O(n)
$$

```C++
class Solution {
public:
    int numTrees(int n) {
        vector<int> dp(n+1,0);
        dp[0]=1;
        for(int i=1;i<=n;i++){
            for(int j=1;j<=i;j++)
                dp[i]+=dp[j-1]*dp[i-j];
        }
        return dp[n];
    }
};
```

## 01背包问题

### 01背包理论

#### 二维dp数组01背包

1. 确定dp数组以及下标的含义

$dp[i][j]$ 表示从下标为$[0,1,...,i]$的物品里任意取，放进容量为 $j$ 的背包，价值总和最大是多少

<img src="动态规划\01背包问题二维数组.png" alt="01背包问题二维数组" style="zoom:50%;" />

2. 确定递推公式

$dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i])$

3. dp数组如何初始化

首先从$dp[i][j]$ 的定义出发，如果背包容量j为0的话，即$dp[i][0]$ ，无论是选取哪些物品，背包价值总和一定为0。如图：

<img src="动态规划\01背包问题二维数组初始化1.png" alt="01背包问题二维数组初始化1" style="zoom:50%;" />

再看其他情况。

状态转移方程 $dp[i][j]$ = $dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i])$; 可以看出i 是由 i-1 推导出来，那么i为0的时候就一定要初始化。

$dp[0][j]$ ，即：i为0，存放编号0的物品的时候，各个容量的背包所能存放的最大价值。

那么很明显当 j < weight[0]的时候，$dp[0][j]$  应该是 0，因为背包容量比编号0的物品重量还小。

当j >= weight[0]时，$dp[0][j]$  应该是value[0]，因为背包容量放足够放编号0物品。

代码初始化如下：

```C++
for (int j = 0 ; j < weight[0]; j++) {
    dp[0][j] = 0;
}
// 正序遍历
for (int j = weight[0]; j <= bagweight; j++) {
    dp[0][j] = value[0];
}
```

<img src="动态规划\01背包问题二维数组初始化2.png" alt="01背包问题二维数组初始化2" style="zoom:50%;" />

4. 确定遍历顺序

**先遍历物品还是先遍历背包重量呢？其实都可以！ 但是先遍历物品更好理解**。

先遍历物品的代码

```C++
// weight数组的大小 就是物品个数
for(int i = 1; i < weight.size(); i++) { // 遍历物品
    for(int j = 0; j <= bagweight; j++) { // 遍历背包容量
        if (j < weight[i]) dp[i][j] = dp[i - 1][j];
        else dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);
    }
}
```

先遍历背包重量的代码

```C++
// weight数组的大小 就是物品个数
for(int j = 0; j <= bagweight; j++) { // 遍历背包容量
    for(int i = 1; i < weight.size(); i++) { // 遍历物品
        if (j < weight[i]) dp[i][j] = dp[i - 1][j];
        else dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);
    }
}
```

为什么也是可以的呢？

**要理解递归的本质和递推的方向**。

$dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i])$; 递归公式中可以看出是$dp[i][j]$靠$dp[i-1][j]$和$dp[i - 1][j - weight]$推导出来的。

$dp[i-1][j]$和$dp[i - 1][j - weight[i]]$ 都在$dp[i][j]$的左上角方向（包括正上方向），因此先遍历物品和先遍历背包的过程都可以。

5. 举例推导dp数组

略。

#### 一维dp数组（滚动数组）

对于背包问题其实状态都是可以压缩的。

在使用二维数组的时候，递推公式：$dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i])$;

**其实可以发现如果把dp[i - 1]那一层拷贝到dp[i]上，表达式完全可以是：$dp[i][j] = max(dp[i][j], dp[i][j - weight[i]] + value[i])$;**

**与其把dp[i - 1]这一层拷贝到dp[i]上，不如只用一个一维数组了**，只用dp[j]（一维数组，也可以理解是一个滚动数组）。

这就是滚动数组的由来，需要满足的条件是上一层可以重复利用，直接拷贝到当前层。

1. 确定dp数组的定义

在一维dp数组中，dp[j]表示：容量为j的背包，所背的物品价值可以最大为dp[j]。

2. 一维dp数组的递推公式

dp[j]可以通过dp[j - weight[i]]推导出来，dp[j - weight[i]]表示容量为j - weight[i]的背包所背的最大价值。

dp[j - weight[i]] + value[i] 表示 容量为 j - 物品i重量 的背包 加上 物品i的价值。（也就是容量为j的背包，放入物品i了之后的价值即：dp[j]）

此时dp[j]有两个选择，一个是取自己dp[j] 相当于 二维dp数组中的$dp[i-1][j]$，即不放物品i，一个是取dp[j - weight[i]] + value[i]，即放物品i，指定是取最大的，毕竟是求最大价值，

所以递归公式为：$dp[j] = max(dp[j], dp[j - weight[i]] + value[i])$;

3. 一维dp数组如何初始化

dp[j]表示：容量为j的背包，所背的物品价值可以最大为dp[j]，那么dp[0]就应该是0，因为背包容量为0所背的物品的最大价值就是0。

那么dp数组除了下标0的位置，初始为0，其他下标应该初始化多少呢？

看一下递归公式：$dp[j] = max(dp[j], dp[j - weight[i]] + value[i])$;

dp数组在推导的时候一定是取价值最大的数，如果题目给的价值都是正整数那么非0下标都初始化为0就可以了。

**这样才能让dp数组在递归公式的过程中取的最大的价值，而不是被初始值覆盖了**。

那么我假设物品价值都是大于0的，所以dp数组初始化的时候，都初始为0就可以了。

4. 一维dp数组遍历顺序

代码如下：

```C++
for(int i = 0; i < weight.size(); i++) { // 遍历物品
    for(int j = bagWeight; j >= weight[i]; j--) { // 遍历背包容量
        dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);
    }
}
```

**==倒序遍历是为了保证物品i只被放入一次！。但如果一旦正序遍历了，那么物品就会被重复加入多次！==**

**再来看看两个嵌套for循环的顺序，代码中是先遍历物品嵌套遍历背包容量，那可不可以先遍历背包容量嵌套遍历物品呢？**

不可以！

因为一维dp的写法，背包容量一定是要倒序遍历（原因上面已经讲了），如果遍历背包容量放在上一层，那么每个dp[j]就只会放入一个物品，即：背包里只放入了一个物品。

倒序遍历的原因是，本质上还是一个对二维数组的遍历，并且右下角的值依赖上一层左上角的值，因此需要保证左边的值仍然是上一层的，从右向左覆盖。

5. 举例推导dp数组

略。

### [416. 分割等和子集](https://leetcode.cn/problems/partition-equal-subset-sum/)

#### 解法1：动态规划

$$
O(n^2)+O(n)
$$

```C++
class Solution {
public:
    bool canPartition(vector<int>& nums) {
        int sum=0;
        for(int i=0;i<nums.size();i++) sum+=nums[i];
        if(sum%2) return false;
        vector<int> dp(sum/2+1,0);
        for(int i=0;i<nums.size();i++)
            for(int j=sum/2;j>=nums[i];j--)
                dp[j]=max(dp[j],dp[j-nums[i]]+nums[i]);
        if(dp[sum/2]==sum/2) return true;
        else return false;
    }
};
```

### 插曲：补充两道回溯

### [698. 划分为k个相等的子集](https://leetcode.cn/problems/partition-to-k-equal-sum-subsets/)（==待做==）

### [473. 火柴拼正方形](https://leetcode.cn/problems/matchsticks-to-square/)（==待做==）







































### [300. 最长递增子序列](https://leetcode.cn/problems/longest-increasing-subsequence/)

#### 解法1：动态规划

$$
O(n^2)+O(n)
$$

```C++
class Solution {
public:
    int lengthOfLIS(vector<int>& nums) {
        vector<int> d;
        for(int i=0;i<nums.size();i++){
            if(i==0||d[d.size()-1]<nums[i]) d.push_back(nums[i]);
            else{
                int l=0,r=d.size()-1;
                while(l<r){
                    int mid=l+r>>1;
                    if(d[mid]>=nums[i]) r=mid;
                    else l=mid+1;
                }
                d[l]=nums[i];
            }
        }
        return d.size();
    }
};
```

#### 解法2：贪心+二分查找5

$$
O(n\log n)+O(n)
$$

```C++
class Solution {
public:
    int lengthOfLIS(vector<int>& nums) {
        vector<int> d;
        for(int i=0;i<nums.size();i++){
            if(i==0||d[d.size()-1]<nums[i]) d.push_back(nums[i]);
            else{
                int l=0,r=d.size()-1;
                while(l<r){
                    int mid=l+r>>1;
                    if(d[mid]>=nums[i]) r=mid;
                    else l=mid+1;
                }
                d[l]=nums[i];
            }
        }
        return d.size();
    }
};
```

### ==[674. 最长连续递增序列](https://leetcode.cn/problems/longest-continuous-increasing-subsequence/)==

#### 解法1：动态规划

$$
O(n)+O(n)
$$

```C++
class Solution {
public:
    int findLengthOfLCIS(vector<int>& nums) {
        int MAX=1;
        vector<int> dp(nums.size(),1);
        for(int i=1;i<nums.size();i++){
            if(nums[i]>nums[i-1]) dp[i]=dp[i-1]+1;
            MAX=max(dp[i],MAX);
        }
        return MAX;
    }
};
```

#### 解法2：贪心

$$
O(n)+O(1)
$$

```C++
class Solution {
public:
    int findLengthOfLCIS(vector<int>& nums) {
        int MAX=1,now;
        for(int i=0;i<nums.size();i++){
            if(i&&nums[i]>nums[i-1]) now++;
            else now=1;
            MAX=max(MAX,now);
        }
        return MAX;
    }
};
```

#### ==笔记==

注意和上一题的不同，上一题要求子序列，本身没有连续的要求，但本题要求连续子序列，类似于子串



